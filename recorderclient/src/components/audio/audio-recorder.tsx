"use client"

import type React from "react"

import { useState, useRef, useEffect, useCallback } from "react"
import { Upload, Mic, Square, Play, Pause, Save, Trash2, PlusCircle, X, Maximize2, Minimize2, ChevronDown, ChevronUp, Grid, List, ArrowUpDown, ArrowDown, ArrowUp, Unlink, Copy, FileText, Pencil, Check } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardFooter } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Textarea } from "@/components/ui/textarea"
import { transcribeAudio, summarizeText, analyzeText, translateText, processTranscript, processWithCustomPrompt } from "@/lib/api-client"
import { toast } from "sonner"
import { useDatabase } from '@/hooks/useDatabase'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog"
import { createClient } from '@/lib/supabase'
import { getCustomPrompts } from '@/lib/db'

interface AudioRecorderProps {
  isAuthenticated: boolean;
  onResultsChange?: (results: Array<{ id: number; type: string; content: string; title?: string; generating: boolean; date?: string; originalId?: string }>) => void;
  initialResults?: Array<{ id: number; type: string; content: string; title?: string; generating: boolean; date?: string; originalId?: string }>;
}

export default function AudioRecorder({ isAuthenticated = false, onResultsChange, initialResults = [] }: AudioRecorderProps) {
  // Basic state
  const [isRecording, setIsRecording] = useState(false)
  const [audioURL, setAudioURL] = useState<string | null>(null)
  const [recordingTime, setRecordingTime] = useState(0)
  const [isPlaying, setIsPlaying] = useState(false)
  const [uploadedFile, setUploadedFile] = useState<File | null>(null)
  const [uploadedAudioURL, setUploadedAudioURL] = useState<string | null>(null)
  const [isUploadedPlaying, setIsUploadedPlaying] = useState(false)
  const [isPostRecording, setIsPostRecording] = useState(false)
  const [selectedAiAction, setSelectedAiAction] = useState<string>("transcribe")
  const [aiProcessing, setAiProcessing] = useState(false)
  const [currentMimeType, setCurrentMimeType] = useState<string>("")
  const [processedResults, setProcessedResults] = useState<Array<{ id: number; type: string; content: string; title?: string; generating: boolean; expanded?: boolean; date?: string; originalId?: string }>>(initialResults);
  const [isMinimized, setIsMinimized] = useState<boolean>(false);
  const [lastTranscriptionId, setLastTranscriptionId] = useState<string | null>(null);
  // View mode state
  const [viewMode, setViewMode] = useState<'card' | 'list'>('card');
  // Add state for active tab
  const [activeTab, setActiveTab] = useState<"record" | "upload" | "write">("record");
  // Sort direction state
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  // Add new state for transcript collapse on mobile
  const [isTranscriptCollapsed, setIsTranscriptCollapsed] = useState<boolean>(true);
  
  // Delete confirmation dialog state
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState<{ id: number; type: string; originalId: string | null }>({ id: 0, type: '', originalId: null });
  
  // Transcript removal confirmation dialog state
  const [transcriptRemovalDialogOpen, setTranscriptRemovalDialogOpen] = useState(false);
  const [transcriptToRemove, setTranscriptToRemove] = useState<{ analysisId: string; resultId: number }>({ analysisId: '', resultId: 0 });
  
  // Modal state for expanded card
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedCard, setSelectedCard] = useState<{ 
    id: number; 
    type: string; 
    content: string; 
    title?: string; 
    date?: string;
    originalId?: string;
  } | null>(null);
  
  // Recording time limit in seconds based on auth status
  const recordingTimeLimit = isAuthenticated ? 600 : 300;
  
  // Add a state for the transcript
  const [transcriptContent, setTranscriptContent] = useState<string>(
    "This is a simulated transcript of your audio recording. It would contain all the spoken words detected in your recording. In a real implementation, this would be generated by a speech-to-text service.\n\nThe transcript would be formatted with paragraphs and punctuation to make it easy to read. It might also include timestamps or speaker identification depending on the service used.",
  )
  const [transcriptProcessingType, setTranscriptProcessingType] = useState<'keep-as-is' | 'condense' | 'expand'>('keep-as-is')
  const [textContent, setTextContent] = useState<string>("")

  // Refs
  const mediaRecorderRef = useRef<MediaRecorder | null>(null)
  const audioChunksRef = useRef<Blob[]>([])
  const audioRef = useRef<HTMLAudioElement | null>(null)
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const uploadedAudioRef = useRef<HTMLAudioElement | null>(null)
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const animationFrameRef = useRef<number | null>(null)
  const analyzerRef = useRef<AnalyserNode | null>(null)
  const micStreamRef = useRef<MediaStream | null>(null)
  const fileInputRef = useRef<HTMLInputElement | null>(null)
  
  // Map to store transcription content for each result
  const [transcriptMap, setTranscriptMap] = useState<Record<number, string>>({});
  // Convert lastTranscriptionId to a numeric ID for use with the transcript map
  const [lastTranscriptionNumericId, setLastTranscriptionNumericId] = useState<number | null>(null);

  // Map to store original IDs for each result
  const [originalIdMap, setOriginalIdMap] = useState<Record<number, string>>({});
  
  // Translation state
  const [translatedContent, setTranslatedContent] = useState<string>("");
  const [isTranslating, setIsTranslating] = useState<boolean>(false);
  const [selectedLanguage, setSelectedLanguage] = useState<string>("english");
  const [translatedTitle, setTranslatedTitle] = useState<string>("");
  const [translationId, setTranslationId] = useState<string | null>(null);
  const [copySuccess, setCopySuccess] = useState<boolean>(false);

  // Initialize transcriptMap from initialResults
  useEffect(() => {
    if (initialResults.length > 0) {
      console.log('AudioRecorder - Initializing transcript map from initialResults');
      const newTranscriptMap: Record<number, string> = {};
      
      initialResults.forEach(result => {
        if (result.type === 'transcribe') {
          console.log(`AudioRecorder - Adding transcription to map: ID=${result.id}, Content=${result.content ? result.content.substring(0, 50) + '...' : 'No content'}`);
          newTranscriptMap[result.id] = result.content;
        }
      });
      
      console.log('AudioRecorder - New transcript map:', Object.keys(newTranscriptMap).length, 'entries');
      setTranscriptMap(newTranscriptMap);
      
      // Also update processedResults to ensure they have the content
      setProcessedResults(initialResults.map(result => ({
        ...result,
        // Ensure expanded is set to false initially
        expanded: false
      })));
    }
  }, [initialResults]);

  // Update lastTranscriptionNumericId when lastTranscriptionId changes
  useEffect(() => {
    if (lastTranscriptionId) {
      // Convert UUID to numeric ID using the same method as in AudioWrapper
      const numericId = parseInt(lastTranscriptionId.replace(/-/g, '').substring(0, 13), 16);
      console.log('AudioRecorder - Setting lastTranscriptionNumericId:', numericId);
      setLastTranscriptionNumericId(numericId);
    }
  }, [lastTranscriptionId]);

  // Function to get transcript content for a specific result
  const getTranscriptContent = (resultId: number) => {
    // First check if it's in the map
    if (transcriptMap[resultId]) {
      console.log(`AudioRecorder - Using stored transcript for result ID ${resultId}:`, 
        typeof transcriptMap[resultId] === 'string' && transcriptMap[resultId].length > 50 
          ? transcriptMap[resultId].substring(0, 50) + '...'
          : transcriptMap[resultId]
      );
      return transcriptMap[resultId];
    }
    
    // If not in map, check if it's in the processedResults
    const result = processedResults.find(r => r.id === resultId);
    if (result && result.type === 'transcribe' && result.content) {
      console.log(`AudioRecorder - Found transcript in processedResults for ID ${resultId}:`, 
        result.content.length > 50 ? result.content.substring(0, 50) + '...' : result.content
      );
      
      // Add it to the map for future use
      setTranscriptMap(prevMap => ({
        ...prevMap,
        [resultId]: result.content
      }));
      
      return result.content;
    }
    
    // If we have transcriptContent set directly, use it when the resultId matches lastTranscriptionNumericId
    if (transcriptContent && resultId === (lastTranscriptionNumericId || 0)) {
      console.log(`AudioRecorder - Using transcriptContent for result ID ${resultId}`);
      
      // Add it to the map for future use
      setTranscriptMap(prevMap => ({
        ...prevMap,
        [resultId]: transcriptContent
      }));
      
      return transcriptContent;
    }
    
    // If there's no content yet but we have an originalId from the result
    if (result && result.originalId) {
      console.log(`AudioRecorder - No content in map, but have originalId for ${resultId}: ${result.originalId}`);
      
      // Set a loading message in the map
      setTranscriptMap(prevMap => ({
        ...prevMap,
        [resultId]: "Loading transcript from database..."
      }));
      
      // For summaries and analyses, we need to get the transcription via the analysis record
      if (result.type === 'summarize' || result.type === 'analyze') {
        console.log(`AudioRecorder - Fetching transcript for analysis ID ${result.originalId}`);
        // Start fetching in the background
        fetchTranscriptionForAnalysis(result.originalId, resultId)
          .then(content => {
            if (content) {
              setTranscriptMap(prevMap => ({
                ...prevMap,
                [resultId]: content
              }));
            }
          });
      } else {
        // For direct transcriptions
        console.log(`AudioRecorder - Fetching transcript from DB for transcription ID ${result.originalId}`);
        // Start fetching in the background
        fetchTranscriptionFromDB(result.originalId, resultId)
          .then(content => {
            if (content) {
              setTranscriptMap(prevMap => ({
                ...prevMap,
                [resultId]: content
              }));
            }
          });
      }
      
      return "Loading transcript from database...";
    }
    
    // If we have a lastTranscriptionId but no content yet, fetch from DB
    if (lastTranscriptionId) {
      // Start fetching from DB if not already started
      console.log(`AudioRecorder - No content, but have lastTranscriptionId: ${lastTranscriptionId}`);
      
      // Set a loading message in the map
      setTranscriptMap(prevMap => ({
        ...prevMap,
        [resultId]: "Loading transcript from database..."
      }));
      
      fetchTranscriptionFromDB(lastTranscriptionId, resultId)
        .then(content => {
          if (content) {
            setTranscriptMap(prevMap => ({
              ...prevMap,
              [resultId]: content
            }));
          }
        });
      
      return "Loading transcript from database...";
    }
    
    return "No transcript available";
  };
  
  // Visualization state for the recording button
  const [audioLevel, setAudioLevel] = useState<number>(0)
  const visualizationIntervalRef = useRef<NodeJS.Timeout | null>(null)
  
  // Add the useDatabase hook
  const { 
    createTranscription, 
    createAnalysis, 
    uploadFile, 
    deleteAnalysis, 
    deleteTranscription, 
    removeTranscriptionReference, 
    getTranscription,
    getAnalysis,
    isLoading: dbLoading, 
    error: databaseError,
    createTranslation,
    getTranslation,
    updateTranslation
  } = useDatabase();
  
  // Effect to check if recording time has reached the limit
  useEffect(() => {
    if (isRecording && recordingTime >= recordingTimeLimit) {
      stopRecording();
      
      // Show toast notification
      if (isAuthenticated) {
        toast.warning("Recording limit reached", {
          description: "You've reached the 10-minute recording limit."
        });
      } else {
        toast.warning("Recording limit reached", {
          description: "You've reached the 5-minute recording limit. Sign in for longer recordings."
        });
      }
    }
  }, [isRecording, recordingTime, recordingTimeLimit, isAuthenticated]);
  
  // Calculate time remaining in seconds
  const timeRemainingSeconds = recordingTimeLimit - recordingTime;
  
  // Format time remaining for display
  const formatTimeRemaining = () => {
    const mins = Math.floor(timeRemainingSeconds / 60);
    const secs = timeRemainingSeconds % 60;
    return `${mins}:${secs < 10 ? "0" : ""}${secs}`;
  };
  
  // Clean up resources when component unmounts
  useEffect(() => {
    return () => {
      // Stop any active recording
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
        try {
          mediaRecorderRef.current.stop()
        } catch (e) {
          console.error("Error stopping media recorder:", e)
        }
      }
      
      // Clear timer
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
      
      // Clear visualization interval
      if (visualizationIntervalRef.current) {
        clearInterval(visualizationIntervalRef.current)
      }
      
      // Stop microphone stream
      if (micStreamRef.current) {
        try {
          micStreamRef.current.getTracks().forEach(track => {
            try {
              track.stop()
            } catch (e) {
              console.error("Error stopping track:", e)
            }
          })
        } catch (e) {
          console.error("Error stopping stream:", e)
        }
      }
      
      // Clean up audio URLs
      if (audioURL) {
        URL.revokeObjectURL(audioURL)
      }
      
      if (uploadedAudioURL) {
        URL.revokeObjectURL(uploadedAudioURL)
      }
    }
  }, [audioURL, uploadedAudioURL])
  
  // Handle audio element events
  useEffect(() => {
    const audioElement = audioRef.current
    
    if (audioElement) {
      const handleEnded = () => {
        console.log("Audio playback ended")
        setIsPlaying(false)
        setIsUploadedPlaying(false)
      }
      
      const handleError = (e: Event) => {
        console.error("Audio element error:", e)
        setIsPlaying(false)
        setIsUploadedPlaying(false)
      }
      
      audioElement.addEventListener('ended', handleEnded)
      audioElement.addEventListener('error', handleError)
      
      return () => {
        audioElement.removeEventListener('ended', handleEnded)
        audioElement.removeEventListener('error', handleError)
      }
    }
  }, [])
  
  // Format time for display
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs < 10 ? "0" : ""}${secs}`
  }
  
  // Start recording
  const startRecording = async () => {
    try {
      console.log("Starting recording...")
      
      // Get microphone stream
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        }
      })
      
      // Store stream reference
      micStreamRef.current = stream
      
      // Reset chunks array
      audioChunksRef.current = []
      
      // Determine the supported MIME type
      const mimeType = getSupportedMimeType();
      console.log("Using MIME type:", mimeType);
      setCurrentMimeType(mimeType || 'audio/mp4');
      
      // Create media recorder with the supported MIME type
      try {
        const options = mimeType ? { mimeType } : { mimeType: 'audio/mp4' };
        mediaRecorderRef.current = new MediaRecorder(stream, options);
        console.log("MediaRecorder created successfully");
      } catch (error) {
        console.error("Error creating MediaRecorder:", error);
        // Try again without specifying a MIME type
        try {
          console.log("Trying to create MediaRecorder without MIME type");
          mediaRecorderRef.current = new MediaRecorder(stream);
          console.log("MediaRecorder created successfully without MIME type");
          // Get the actual MIME type being used
          if (mediaRecorderRef.current.mimeType) {
            setCurrentMimeType(mediaRecorderRef.current.mimeType);
            console.log("Using browser-selected MIME type:", mediaRecorderRef.current.mimeType);
          } else {
            setCurrentMimeType('audio/mp4'); // Default fallback
          }
        } catch (fallbackError) {
          console.error("Failed to create MediaRecorder even without MIME type:", fallbackError);
          alert("Your browser doesn't support audio recording. Please try a different browser.");
          // Clean up
          if (micStreamRef.current) {
            micStreamRef.current.getTracks().forEach(track => track.stop());
          }
          return;
        }
      }
      
      // Set up event handlers
      mediaRecorderRef.current.ondataavailable = (event) => {
        console.log("Data available:", event.data?.size)
        if (event.data && event.data.size > 0) {
          audioChunksRef.current.push(event.data)
        }
      }
      
      mediaRecorderRef.current.onstop = () => {
        console.log("MediaRecorder stopped, chunks:", audioChunksRef.current.length);
        if (audioChunksRef.current.length === 0) {
          console.warn("No audio data was recorded");
          return;
        }
        try {
          console.log("Creating audio blob with MIME type: audio/mp4");
          const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/mp4' });
          const url = URL.createObjectURL(audioBlob);
          setAudioURL(url);
          console.log("Audio blob created successfully");

          // Start automatic transcription
          setAiProcessing(true);
          (async () => {
            try {
              console.log("Calling transcribeAudio with audio blob");
              const result = await transcribeAudio(audioBlob);
              let transcript = "";
              if (result.success && result.text) {
                transcript = result.text;
                setTranscriptContent(transcript);
                
                // If user is authenticated, save to database
                if (isAuthenticated) {
                  try {
                    // Upload the audio file to database
                    const fileData = await uploadFile(
                      new File([audioBlob], `recording_${new Date().toISOString()}.mp4`, { type: audioBlob.type })
                    );
                    
                    if (fileData && fileData.id) {
                      // Save the transcription
                      const transcriptionData = await createTranscription(
                        fileData.id, 
                        "Transcript", 
                        transcript,
                        recordingTime,
                        { source: "recorder", isDirectTranscription: true }
                      );
                      
                      // Store the transcription ID
                      if (transcriptionData) {
                        setLastTranscriptionId(transcriptionData.id);
                        
                        // If we have a transcription ID, convert it to a numeric ID and store the transcript in the map
                        if (transcriptionData?.id) {
                          const numericId = parseInt(transcriptionData.id.replace(/-/g, '').substring(0, 13), 16);
                          console.log('Setting transcript in map for ID:', numericId);
                          setTranscriptMap(prevMap => ({
                            ...prevMap,
                            [numericId]: transcript
                          }));
                          
                          // Also store the original ID in the originalIdMap
                          setOriginalIdMap(prevMap => ({
                            ...prevMap,
                            [numericId]: transcriptionData.id
                          }));
                          
                          // Update the lastTranscriptionNumericId
                          setLastTranscriptionNumericId(numericId);
                        }
                      }
                    } else {
                      console.error("Failed to upload audio file to database");
                    }
                  } catch (dbError) {
                    console.error("Error saving to database:", dbError);
                  }
                }
              } else {
                transcript = "Error: " + (result.error || "Unknown transcription error");
                setTranscriptContent(transcript);
              }
            } catch (e) {
              console.error("Error in transcription process:", e);
              setTranscriptContent("Error: " + (e instanceof Error ? e.message : String(e)));
            } finally {
              setAiProcessing(false);
            }
          })();

        } catch (error) {
          console.error("Error creating audio blob:", error);
          // Fallback logic
          try {
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/mp4' });
            const url = URL.createObjectURL(audioBlob);
            setAudioURL(url);
            setCurrentMimeType('audio/mp4');
            console.log("Created audio blob with fallback MIME type: audio/mp4");
          } catch (fallbackError) {
            console.error("Failed to create audio blob even with fallback:", fallbackError);
            alert("There was an error processing your recording.");
          }
        }
      }
      
      // Start recording
      mediaRecorderRef.current.start(100) // Capture in 100ms chunks
      
      // Update UI state
      setIsRecording(true)
      setRecordingTime(0)
      setIsPostRecording(false)
      
      // Start timer
      timerRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1)
      }, 1000)
      
      // Start visualization for the recording button
      startVisualization(stream)
      
      console.log("Recording started successfully")
    } catch (error) {
      console.error("Error starting recording:", error)
    }
  }
  
  // Start visualization for the recording button
  const startVisualization = (stream: MediaStream) => {
    try {
      // Clear any existing visualization interval
      if (visualizationIntervalRef.current) {
        clearInterval(visualizationIntervalRef.current)
      }
      
      // Create audio context and analyzer
      // Define the AudioContext type that includes webkitAudioContext
      type AudioContextType = typeof AudioContext
      
      // Define a type for the window with webkitAudioContext
      interface WindowWithWebkitAudio extends Window {
        webkitAudioContext?: AudioContextType;
      }
      
      const AudioContextClass: AudioContextType = 
        window.AudioContext || (window as WindowWithWebkitAudio).webkitAudioContext || null as unknown as AudioContextType;
      
      const audioContext = new AudioContextClass()
      const analyser = audioContext.createAnalyser()
      analyser.fftSize = 256
      analyser.smoothingTimeConstant = 0.3 // Make it more responsive (lower = more responsive)
      
      // Connect microphone to analyzer
      const source = audioContext.createMediaStreamSource(stream)
      source.connect(analyser)
      
      // Create data array for frequency data
      const dataArray = new Uint8Array(analyser.frequencyBinCount)
      
      // Update visualization at regular intervals
      visualizationIntervalRef.current = setInterval(() => {
        // Get frequency data
        analyser.getByteFrequencyData(dataArray)
        
        // Calculate average level with emphasis on lower frequencies
        // which are more common in speech
        let sum = 0
        let weight = 0
        for (let i = 0; i < dataArray.length; i++) {
          // Give more weight to lower frequencies (first third of the spectrum)
          const frequencyWeight = i < dataArray.length / 3 ? 3 : 1
          sum += dataArray[i] * frequencyWeight
          weight += frequencyWeight
        }
        const avg = sum / weight
        
        // Update audio level (0-100 scale) with smoother transitions
        // Amplify the effect by multiplying the raw value
        setAudioLevel(prev => {
          // Smooth transitions by blending previous and new values
          const amplifiedLevel = Math.min(100, avg * 1.5) // Amplify by 1.5x
          return prev * 0.2 + amplifiedLevel * 0.8 // 80% new value, 20% old value for more responsiveness
        })
      }, 20) // Update 50 times per second for smoother animation
      
      // Clean up when recording stops
      return () => {
        clearInterval(visualizationIntervalRef.current!)
        audioContext.close()
      }
    } catch (error) {
      console.error("Error starting visualization:", error)
    }
  }
  
  // Get dynamic gradient position based on audio level
  const getGradientPosition = () => {
    // Map audio level (0-100) to gradient position (100%-0%)
    // When audio level is high, gradient moves up (lower percentage)
    // When audio level is low, gradient moves down (higher percentage)
    const position = 100 - audioLevel;
    return `${position}%`
  }
  
  // Get button styles for recording button
  const getRecordingButtonStyles = () => {
    // Fixed size for the button
    const size = '4rem';
    
    // Create a dynamic background with gradient that moves based on audio level
    return {
      width: size,
      height: size,
      background: `linear-gradient(to top, #ef4444 ${getGradientPosition()}, #f87171 100%)`,
      boxShadow: `0 0 ${Math.max(5, audioLevel / 5)}px rgba(239, 68, 68, 0.6)`,
      transition: 'box-shadow 0.1s ease-in-out',
    };
  }
  
  // Get button styles for stop button
  const getStopButtonStyles = () => {
    // Fixed size for the button
    const size = '4rem';
    
    // Create a dynamic background with gradient that moves based on audio level
    return {
      width: size,
      height: size,
      background: `linear-gradient(to top, #b91c1c ${getGradientPosition()}, #ef4444 100%)`,
      boxShadow: `0 0 ${Math.max(5, audioLevel / 5)}px rgba(185, 28, 28, 0.6)`,
      transition: 'box-shadow 0.1s ease-in-out',
    };
  }
  
  // Stop recording
  const stopRecording = () => {
    try {
      console.log("Stopping recording...")
      
      // Stop timer
      if (timerRef.current) {
        clearInterval(timerRef.current)
        timerRef.current = null
      }
      
      // Stop visualization
      if (visualizationIntervalRef.current) {
        clearInterval(visualizationIntervalRef.current)
        visualizationIntervalRef.current = null
      }
      
      // Stop media recorder
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
        mediaRecorderRef.current.stop()
      }
      
      // Stop microphone stream
      if (micStreamRef.current) {
        micStreamRef.current.getTracks().forEach(track => track.stop())
        micStreamRef.current = null
      }
      
      // Update UI state
      setIsRecording(false)
      setIsPostRecording(true)
      setAudioLevel(0)
      
      console.log("Recording stopped successfully")
    } catch (error) {
      console.error("Error stopping recording:", error)
      setIsRecording(false)
      setIsPostRecording(true)
    }
  }
  
  // Reset recorder to initial state
  const resetRecorder = () => {
    // Clear previous recording
    if (audioURL) {
      URL.revokeObjectURL(audioURL)
      setAudioURL(null)
    }
    
    // Reset to initial state
    setIsPostRecording(false)
    setIsRecording(false)
    setRecordingTime(0)
    setAiProcessing(false)
    setIsPlaying(false)
    
    // Stop audio playback if it's playing
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
    }
  }
  
  // Handle file upload
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (files && files.length > 0) {
      const file = files[0]
      
      // Check if the file is an audio or video file (MP4 files are often identified as video/mp4)
      if (!file.type.startsWith('audio/') && !file.type.startsWith('video/')) {
        alert('Please upload an audio or video file')
        return
      }
      
      console.log("Uploaded file type:", file.type)
      setUploadedFile(file)
      
      // Create a URL for the uploaded file
      const url = URL.createObjectURL(file)
      
      // If we previously had an uploaded file, revoke its URL
      if (uploadedAudioURL) {
        URL.revokeObjectURL(uploadedAudioURL)
      }
      
      setUploadedAudioURL(url)
      setCurrentMimeType('audio/mp4') // Treat all uploads as MP4 for consistency
      
      // Reset any previous recording state
      if (isPostRecording) {
        resetRecorder()
      }
      
      // Start automatic transcription of the uploaded file
      setAiProcessing(true);
      
      // Convert File to Blob for transcription
      (async () => {
        try {
          // Transcribe the audio
          const result = await transcribeAudio(file); // Using file which is already defined
          
          let transcript = ""; // Declare transcript variable at the right scope level
          
          if (result.success && result.text) {
            transcript = result.text;
            setTranscriptContent(transcript);
            
            // If user is authenticated, save to database
            if (isAuthenticated) {
              try {
                // Upload the audio file to database
                const fileData = await uploadFile(
                  // Use file variable which is already a File object in this function
                  file
                );
                
                if (fileData && fileData.id) {
                  // Save the transcription
                  const transcriptionData = await createTranscription(
                    fileData.id, 
                    "Transcript", 
                    transcript,
                    uploadedAudioRef.current?.duration || 0, // Use the audio duration
                    { source: "upload", isDirectTranscription: true }
                  );
                  
                  // Store the transcription ID
                  if (transcriptionData) {
                    setLastTranscriptionId(transcriptionData.id);
                    
                    // If we have a transcription ID, convert it to a numeric ID and store the transcript in the map
                    if (transcriptionData?.id) {
                      const numericId = parseInt(transcriptionData.id.replace(/-/g, '').substring(0, 13), 16);
                      console.log('Setting transcript in map for ID:', numericId);
                      setTranscriptMap(prevMap => ({
                        ...prevMap,
                        [numericId]: transcript
                      }));
                      
                      // Also store the original ID in the originalIdMap
                      setOriginalIdMap(prevMap => ({
                        ...prevMap,
                        [numericId]: transcriptionData.id
                      }));
                      
                      // Update the lastTranscriptionNumericId
                      setLastTranscriptionNumericId(numericId);
                    }
                  }
                } else {
                  console.error("Failed to upload audio file to database");
                }
              } catch (dbError) {
                console.error("Error saving uploaded file to database:", dbError);
              }
            }
          } else {
            transcript = "Error: " + (result.error || "Unknown transcription error");
            setTranscriptContent(transcript);
            toast.error("Transcription failed", {
              description: result.error || "Unknown transcription error"
            });
          }
        } catch (e) {
          console.error("Error in transcription process:", e);
          setTranscriptContent("Error: " + (e instanceof Error ? e.message : String(e)));
          toast.error("Transcription failed", {
            description: "An error occurred during transcription."
          });
        } finally {
          setAiProcessing(false);
        }
      })();
    }
  }
  
  // Toggle play recorded audio
  const togglePlayRecorded = () => {
    if (audioRef.current && audioURL) {
      if (isPlaying) {
        audioRef.current.pause()
      } else {
        // Make sure we reset the audio element before setting a new source
        audioRef.current.pause()
        audioRef.current.currentTime = 0
        audioRef.current.src = audioURL
        
        // Add error handling for playback
        const playPromise = audioRef.current.play()
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.error("Error playing recorded audio:", error)
            alert("Error playing audio. Please try recording again.")
            setIsPlaying(false)
          })
        }
      }
      setIsPlaying(!isPlaying)
    }
  }
  
  // Toggle play uploaded audio
  const togglePlayUploaded = () => {
    if (audioRef.current && uploadedAudioURL) {
      if (isUploadedPlaying) {
        audioRef.current.pause()
      } else {
        // Make sure we reset the audio element before setting a new source
        audioRef.current.pause()
        audioRef.current.currentTime = 0
        audioRef.current.src = uploadedAudioURL
        
        // Add error handling for playback
        const playPromise = audioRef.current.play()
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.error("Error playing uploaded audio:", error)
            alert("Error playing audio. The file format may not be supported.")
            setIsUploadedPlaying(false)
          })
        }
      }
      setIsUploadedPlaying(!isUploadedPlaying)
    }
  }
  
  // Process with AI
  const processWithAI = async () => {
    setAiProcessing(true);
    const newId = new Date().getTime();
    
    // Add a new result card with generating state for all actions, including transcribe
    setProcessedResults(prev => [
      ...prev,
      { 
        id: newId, 
        type: selectedAiAction, 
        content: "", 
        title: selectedAiAction === "transcribe" 
          ? transcriptProcessingType === 'keep-as-is' 
            ? "Transcript" 
            : transcriptProcessingType === 'condense' 
              ? "Condensed Transcript" 
              : "Expanded Transcript"
          : "", 
        generating: true, 
        expanded: false,
        date: new Date().toISOString() // Add date field
      }
    ]);

    try {
      if (selectedAiAction === "transcribe") {
        // For transcribe, we use the selectedTranscriptAction to determine how to process
        // For the write tab, use the textContent instead of transcriptContent if it's set
        const content = textContent || transcriptContent;
        let processedContent = content;
        let title = transcriptProcessingType === 'keep-as-is' 
          ? "Transcript" 
          : transcriptProcessingType === 'condense' 
            ? "Condensed Transcript" 
            : "Expanded Transcript";
        
        try {
          if (transcriptProcessingType !== 'keep-as-is') {
            // Process the transcript with the selected type
            const processResult = await processTranscript(content, transcriptProcessingType);
            
            if (processResult.success && processResult.content) {
              processedContent = processResult.content;
            } else {
              console.error("Error processing transcript:", processResult.error);
              // Use the original content if processing failed
              processedContent = content;
            }
          }
          
          // Store the transcription in the database if user is authenticated
          if (isAuthenticated) {
            try {
              // Create a placeholder text file to satisfy the foreign key constraint
              const placeholderContent = new Blob(['This is a placeholder file for transcript processing'], { type: 'text/plain' });
              const placeholderFile = new File([placeholderContent], `placeholder_${Date.now()}.txt`, { 
                type: 'text/plain' 
              });
              
              // Upload the placeholder file to get a valid file_id
              const fileData = await uploadFile(placeholderFile);
              
              if (!fileData || !fileData.id) {
                throw new Error("Failed to create placeholder file");
              }
              
              // Create a transcription record with the valid file_id
              const transcriptionData = await createTranscription(
                fileData.id,
                title,
                processedContent,
                recordingTime, // Duration as number
                { source: "recorder", isDirectTranscription: true, processingType: transcriptProcessingType, isPlaceholder: true }
              );
              
              console.log("Transcription saved to database");
              
              // Update the result card with the processed content
              setProcessedResults(prev => prev.map(item => 
                item.id === newId 
                  ? { 
                      ...item, 
                      content: processedContent,
                      title: title,
                      generating: false,
                      originalId: transcriptionData?.id
                    } 
                  : item
              ));
              
              // If we have a transcription ID, store it for later use
              if (transcriptionData?.id) {
                // Store the transcript content in the transcriptMap
                setTranscriptMap(prevMap => ({
                  ...prevMap,
                  [newId]: processedContent
                }));
                
                // Also store the original ID in the originalIdMap
                setOriginalIdMap(prevMap => ({
                  ...prevMap,
                  [newId]: transcriptionData.id
                }));
              }
            } catch (dbError) {
              console.error("Error saving transcription to database:", dbError);
              
              // Update the result card with an error if saving failed
              setProcessedResults(prev => prev.map(item => 
                item.id === newId 
                  ? { 
                      ...item, 
                      content: processedContent, // Still show the processed content
                      title: title,
                      generating: false,
                    } 
                  : item
              ));
            }
          } else {
            // Not authenticated, just update the UI
            setProcessedResults(prev => prev.map(item => 
              item.id === newId 
                ? { 
                    ...item, 
                    content: processedContent,
                    title: title,
                    generating: false,
                  } 
                : item
            ));
          }
        } catch (processingError) {
          console.error("Error in transcript processing:", processingError);
          
          // Update the result card with an error
          setProcessedResults(prev => prev.map(item => 
            item.id === newId 
              ? { 
                  ...item, 
                  content: `Error: ${processingError instanceof Error ? processingError.message : "Failed to process transcript"}`, 
                  title: "Error Processing Transcript", 
                  generating: false 
                } 
              : item
          ));
        }
      } else if (selectedAiAction === "custom-prompt") {
        if (!selectedPromptId) {
          // Handle error - no prompt selected
          console.error("No custom prompt selected");
          setProcessedResults(prev => prev.map(item => 
            item.id === newId 
              ? { 
                  ...item, 
                  content: "Error: No custom prompt selected", 
                  title: "Error", 
                  generating: false 
                } 
              : item
          ));
          return;
        }

        try {
          console.log("Processing with custom prompt ID:", selectedPromptId);
          
          // Check if the selectedPromptId is valid
          const selectedPrompt = customPrompts.find(p => p.id === selectedPromptId);
          if (!selectedPrompt) {
            console.error("Selected prompt not found in customPrompts list. Selected ID:", selectedPromptId, "Available prompts:", customPrompts);
            throw new Error("Selected prompt not found in the list of available prompts");
          }
          
          console.log("Using prompt:", selectedPrompt.title);
          
          // Process transcript with the selected custom prompt
          const result = await processWithCustomPrompt(transcriptContent, selectedPromptId);
          
          console.log("Custom prompt processing result:", result);
          
          if (result.success) {
            const content = result.content || "";
            const title = result.title || "Custom Processing Result";
            
            // Store the result in the database if user is authenticated
            let analysisId = null;
            if (isAuthenticated) {
              try {
                // Use the lastTranscriptionId if available, otherwise use null
                const transcriptionId = lastTranscriptionId || null;
                
                const analysisData = await createAnalysis(
                  transcriptionId,
                  title,
                  content,
                  "custom-prompt",
                  { source: "recorder", customPromptId: selectedPromptId }
                );
                
                console.log("Custom prompt result saved to database");
                analysisId = analysisData?.id;
              } catch (dbError) {
                console.error("Error saving custom prompt result to database:", dbError);
              }
            }
            
            // Update the result card with the processed content
            setProcessedResults(prev => prev.map(item => 
              item.id === newId 
                ? { 
                    ...item, 
                    content,
                    title,
                    generating: false,
                    originalId: analysisId
                  } 
                : item
            ));
            
            // If we have an analysis ID, store it in the originalIdMap
            if (analysisId) {
              setOriginalIdMap(prevMap => ({
                ...prevMap,
                [newId]: analysisId
              }));
            }
          } else {
            // Handle error
            setProcessedResults(prev => prev.map(item => 
              item.id === newId 
                ? { 
                    ...item, 
                    content: "Error: Failed to process with custom prompt", 
                    title: "Error", 
                    generating: false 
                  } 
                : item
            ));
          }
        } catch (error) {
          console.error("Error processing with custom prompt:", error);
          
          // Update the result card with an error
          setProcessedResults(prev => prev.map(item => 
            item.id === newId 
              ? { 
                  ...item, 
                  content: `Error: ${error instanceof Error ? error.message : "Failed to process with custom prompt"}`, 
                  title: "Error", 
                  generating: false 
                } 
              : item
          ));
        }
      }
    } catch (error) {
      console.error("Error in processWithAI:", error);
      
      // Update the result card with a generic error
      setProcessedResults(prev => prev.map(item => 
        item.id === newId 
          ? { 
              ...item, 
              content: `Error: ${error instanceof Error ? error.message : "An unexpected error occurred"}`, 
              title: "Error", 
              generating: false 
            } 
          : item
      ));
    } finally {
      setAiProcessing(false);
      
      // Notify parent component of results change if callback is provided
      if (onResultsChange) {
        onResultsChange(processedResults);
      }
    }
  };

  // Helper function to determine the supported MIME type
  const getSupportedMimeType = () => {
    // Only support MP4 format as requested
    if (MediaRecorder.isTypeSupported('audio/mp4')) {
      console.log('Browser supports recording in audio/mp4 format');
      return 'audio/mp4';
    }
    
    console.warn('MP4 format not supported. Using default browser implementation.');
    // Fallback to default (browser will choose)
    return '';
  };

  // Helper function to get file extension from MIME type
  const getFileExtensionFromMimeType = (mimeType: string): string => {
    // Default to mp4 as requested
    if (!mimeType || mimeType.includes('mp4')) return 'mp4';
    if (mimeType.includes('webm')) return 'webm';
    if (mimeType.includes('ogg')) return 'ogg';
    if (mimeType.includes('wav')) return 'wav';
    if (mimeType.includes('mp3') || mimeType.includes('mpeg')) return 'mp3';
    if (mimeType.includes('aac')) return 'aac';
    
    // Default fallback
    return 'mp4';
  };

  // Call onResultsChange when processedResults changes
  useEffect(() => {
    if (onResultsChange) {
      onResultsChange(processedResults);
    }
  }, [processedResults, onResultsChange]);

  // Function to toggle expanded state for a card
  const toggleCardExpanded = (id: number) => {
    console.log(`AudioRecorder - Toggling card expanded state for ID ${id}`);
    
    // Find the card to display in the modal
    const result = processedResults.find(r => r.id === id);
    if (result) {
      setSelectedCard(result);
      setModalOpen(true);
      
      // If it's a transcript card, ensure we have the transcript content
      if (result.type === 'transcribe') {
        console.log(`AudioRecorder - Expanding transcription card ${id}, checking for content`);
        
        // If we don't have the content in the map, try to get it from the result
        if (!transcriptMap[id] && result.content) {
          console.log(`AudioRecorder - Adding missing transcript to map for ID ${id}`);
          setTranscriptMap(prevMap => ({
            ...prevMap,
            [id]: result.content
          }));
        }
      }
    }
  };

  // Add useEffect to show database errors
  useEffect(() => {
    if (databaseError) {
      toast.error("Database Error", {
        description: databaseError
      });
    }
  }, [databaseError]);

  // Notify parent component about initial results
  useEffect(() => {
    console.log('AudioRecorder - Initial results:', initialResults.length);
    console.log('AudioRecorder - Processed results:', processedResults.length);
    
    if (initialResults.length > 0 && onResultsChange) {
      console.log('AudioRecorder - Notifying parent about initial results');
      onResultsChange(processedResults);
    }
  }, [initialResults, onResultsChange, processedResults]);

  // Set initial results when they change
  useEffect(() => {
    if (initialResults.length > 0) {
      console.log('AudioRecorder - Setting initial results:', initialResults.length);
      setProcessedResults(initialResults);
    }
  }, [initialResults]);

  // Function to handle delete confirmation
  const handleDeleteClick = (id: number, type: string, originalId: string | null) => {
    console.log(`AudioRecorder - Opening delete confirmation for ${type} ID ${id}, original ID: ${originalId}`);
    setItemToDelete({ id, type, originalId });
    setDeleteDialogOpen(true);
  };

  // Function to handle transcript removal confirmation
  const handleTranscriptRemovalClick = (analysisId: string, resultId: number) => {
    console.log(`AudioRecorder - Handling transcript removal click for analysis ID ${analysisId}, result ID ${resultId}`);
    setTranscriptToRemove({ analysisId, resultId });
    setTranscriptRemovalDialogOpen(true);
    
    // Immediately hide the transcript expandable section
    const transcriptEl = document.getElementById(`modal-transcript-${resultId}`);
    if (transcriptEl && !transcriptEl.classList.contains('hidden')) {
      transcriptEl.classList.add('hidden');
    }
  };

  // Function to handle actual deletion
  const handleConfirmDelete = async () => {
    console.log(`[DELETE UI DEBUG] Confirming delete for ${itemToDelete.type} ID ${itemToDelete.id}, original ID: ${itemToDelete.originalId}`);
    
    if (!itemToDelete.originalId) {
      console.error('[DELETE UI DEBUG] Cannot delete item: missing original ID');
      toast.error('Delete failed', { description: 'Could not find the item to delete' });
      return;
    }
    
    try {
      let success = false;
      
      if (itemToDelete.type === 'transcribe') {
        // Mark the transcription as deleted instead of actually deleting it
        console.log(`[DELETE UI DEBUG] Calling deleteTranscription with originalId: ${itemToDelete.originalId}`);
        success = await deleteTranscription(itemToDelete.originalId);
        console.log(`[DELETE UI DEBUG] deleteTranscription result: ${success}`);
      } else if (itemToDelete.type === 'summarize' || itemToDelete.type === 'analyze') {
        // For analyses and summaries, actually delete the record
        console.log(`[DELETE UI DEBUG] Calling deleteAnalysis with originalId: ${itemToDelete.originalId}`);
        success = await deleteAnalysis(itemToDelete.originalId);
        console.log(`[DELETE UI DEBUG] deleteAnalysis result: ${success}`);
      }
      
      if (success) {
        console.log(`[DELETE UI DEBUG] Delete was successful, removing item ${itemToDelete.id} from UI`);
        // Remove the item from processedResults
        setProcessedResults(prevResults => 
          prevResults.filter(result => result.id !== itemToDelete.id)
        );
        
        // Notify parent component
        if (onResultsChange) {
          console.log('[DELETE UI DEBUG] Notifying parent component of the deletion');
          onResultsChange(processedResults.filter(result => result.id !== itemToDelete.id));
        }
        
        toast.success('Item deleted successfully');
      } else {
        console.error('[DELETE UI DEBUG] Delete operation returned false');
        toast.error('Delete failed', { description: 'Could not delete the item' });
      }
    } catch (error) {
      console.error('[DELETE UI DEBUG] Error deleting item:', error);
      toast.error('Delete failed', { description: String(error) });
    } finally {
      setDeleteDialogOpen(false);
    }
  };

  // Initialize originalIdMap from initialResults
  useEffect(() => {
    if (initialResults.length > 0) {
      console.log('AudioRecorder - Initializing originalIdMap from initialResults');
      const newOriginalIdMap: Record<number, string> = {};
      
      initialResults.forEach(result => {
        if (result.originalId) {
          console.log(`AudioRecorder - Adding original ID to map: ID=${result.id}, Original ID=${result.originalId}`);
          newOriginalIdMap[result.id] = result.originalId;
        }
      });
      
      console.log('AudioRecorder - New originalIdMap:', Object.keys(newOriginalIdMap).length, 'entries');
      setOriginalIdMap(newOriginalIdMap);
    }
  }, [initialResults]);

  // Function to get the original transcript from the database for a given analysis
  const fetchTranscriptionForAnalysis = useCallback(async (analysisId: string, resultId?: number) => {
    try {
      console.log(`AudioRecorder - Fetching transcription for analysis ID ${analysisId}`);
      
      // Get the analysis to find the transcription ID
      const analysis = await getAnalysis(analysisId);
      
      // Make sure we have an analysis and a valid transcription ID
      if (!analysis) {
        console.log(`AudioRecorder - No analysis found for ID ${analysisId}`);
        return "No analysis found.";
      }
      
      if (!analysis.transcription_id) {
        console.log(`AudioRecorder - Analysis has no associated transcription ID`);
        return "No associated transcript.";
      }
      
      // Get the transcription details
      const transcription = await getTranscription(analysis.transcription_id);
      
      // Check if we have a valid transcription
      if (!transcription) {
        console.log(`AudioRecorder - No transcription found for ID ${analysis.transcription_id}`);
        return "Transcript not found.";
      }
      
      // Return the transcription content
      console.log(`AudioRecorder - Found transcription content for analysis ID ${analysisId}`);
      return transcription.content || "No content in transcript.";
    } catch (error) {
      console.error("Error fetching transcription for analysis:", error);
      return "Error loading associated transcript.";
    }
  }, [getAnalysis, getTranscription]);

  // Prefetch transcription data for analyses and summaries when component mounts
  useEffect(() => {
    if (initialResults.length > 0) {
      console.log('AudioRecorder - Checking if we need to prefetch any transcription data');
      
      // Get all analyses and summaries that have originalId
      const analysesAndSummaries = initialResults.filter(
        result => (result.type === 'analyze' || result.type === 'summarize') && result.originalId
      );
      
      if (analysesAndSummaries.length > 0) {
        console.log(`AudioRecorder - Found ${analysesAndSummaries.length} analyses/summaries that might need transcription data`);
        
        // Prefetch the first one to avoid loading delay when user first clicks
        const firstItem = analysesAndSummaries[0];
        if (firstItem.originalId) {
          console.log(`AudioRecorder - Prefetching transcription data for analysis ID ${firstItem.originalId}`);
          fetchTranscriptionForAnalysis(firstItem.originalId).catch(err => {
            console.error('Error prefetching transcription data:', err);
          });
        }
      }
    }
  }, [initialResults, fetchTranscriptionForAnalysis]);

  // Function to get the original transcript from the database for a given originalId
  const fetchTranscriptionFromDB = useCallback(async (originalId: string, resultId?: number) => {
    try {
      if (!originalId) {
        console.error("Cannot fetch transcript: originalId is undefined or null");
        return null;
      }
      
      console.log(`AudioRecorder - Attempting to fetch transcription with ID: ${originalId}`);
      
      // Get the transcription from the database
      const transcription = await getTranscription(originalId);
      
      if (!transcription) {
        console.log(`AudioRecorder - Transcription not found or marked as deleted, ID: ${originalId}`);
        // Return a special value to indicate the transcript is deleted
        return "__TRANSCRIPT_DELETED__";
      }
      
      console.log(`AudioRecorder - Successfully fetched transcription from DB, ID: ${originalId}`);
      
      // Use the provided resultId if available, otherwise use lastTranscriptionNumericId
      const mapKey = resultId !== undefined ? resultId : (lastTranscriptionNumericId || 0);
      
      // Update transcript map with the content from the database
      setTranscriptMap(prevMap => ({
        ...prevMap,
        [mapKey]: transcription.content
      }));
      
      return transcription.content;
    } catch (error) {
      console.error("Error fetching transcription:", error);
      
      // Check if it's the specific error we're seeing
      if (error instanceof Error && error.message.includes("multiple (or no) rows returned")) {
        console.log("This is likely because the transcription ID is invalid or the record doesn't exist");
        toast.error("Transcript not found", { 
          description: "The original transcript couldn't be found in the database." 
        });
        return "Original transcript not available.";
      }
      
      toast.error("Failed to load transcript", { 
        description: "Could not fetch the original transcript from the database." 
      });
      return "Error loading transcript.";
    }
  }, [getTranscription, lastTranscriptionNumericId]);

  // Function to handle removing transcription reference
  const handleRemoveTranscriptionReference = async (analysisId: string, resultId: number) => {
    console.log(`AudioRecorder - Removing transcription reference from analysis ID ${analysisId}`);
    
    if (!analysisId) {
      console.error('Cannot remove reference: missing analysis ID');
      toast.error('Operation failed', { description: 'Could not find the analysis' });
      return;
    }
    
    try {
      // First, update the UI immediately to remove the expandable section
      // Set the special value in the transcriptMap to indicate the transcript is deleted
      setTranscriptMap(prevMap => {
        console.log(`AudioRecorder - Setting transcript map for ${resultId} to __TRANSCRIPT_DELETED__`);
        return {
          ...prevMap,
          [resultId]: "__TRANSCRIPT_DELETED__"
        };
      });
      
      // Close the confirmation dialog
      setTranscriptRemovalDialogOpen(false);
      
      // Hide the transcript expandable section if it's open
      const transcriptEl = document.getElementById(`modal-transcript-${resultId}`);
      if (transcriptEl && !transcriptEl.classList.contains('hidden')) {
        transcriptEl.classList.add('hidden');
      }
      
      // Force a re-render of the component by updating the selectedCard
      if (selectedCard && selectedCard.id === resultId) {
        setSelectedCard({...selectedCard});
      }
      
      // Show success toast
      toast.success('Transcript reference removed');
      
      // Then, perform the database operation in the background
      // Get the analysis to find its transcription_id
      const analysis = await getAnalysis(analysisId);
      
      if (!analysis || !analysis.transcription_id) {
        console.error('No transcription reference found');
        return;
      }
      
      // Mark the transcription as deleted
      const success = await deleteTranscription(analysis.transcription_id);
      
      if (!success) {
        console.error('Could not mark the transcript as deleted in the database');
        // We don't show an error toast here since the UI is already updated
      }
    } catch (error) {
      console.error('Error marking transcript as deleted:', error);
      // We don't show an error toast here since the UI is already updated
    }
  };

  // Update selectedCard when modalOpen changes
  useEffect(() => {
    if (modalOpen && selectedCard) {
      console.log(`AudioRecorder - Modal opened for card ID ${selectedCard.id}, type ${selectedCard.type}`);
      console.log(`AudioRecorder - Transcript map for this card:`, transcriptMap[selectedCard.id]);
      console.log(`AudioRecorder - Is transcript deleted:`, transcriptMap[selectedCard.id] === "__TRANSCRIPT_DELETED__");
    }
  }, [modalOpen, selectedCard, transcriptMap]);

  // Function to sort results by date
  const getSortedResults = useCallback(() => {
    return [...processedResults].sort((a, b) => {
      const dateA = a.date ? new Date(a.date).getTime() : 0;
      const dateB = b.date ? new Date(b.date).getTime() : 0;
      return sortDirection === "asc" ? dateA - dateB : dateB - dateA;
    });
  }, [processedResults, sortDirection]);

  // Toggle sort direction
  const toggleSortDirection = () => {
    setSortDirection(prev => prev === "asc" ? "desc" : "asc");
  };

  const toggleCardSelection = (id: number, e?: React.MouseEvent) => {
    if (e) {
      e.stopPropagation();
    }
    
    setSelectedCards(prev => {
      if (prev.includes(id)) {
        return prev.filter(cardId => cardId !== id);
      } else {
        return [...prev, id];
      }
    });
  };

  // Select all visible cards
  const selectAllCards = () => {
    const allVisibleCardIds = getSortedResults().map(result => result.id);
    setSelectedCards(allVisibleCardIds);
  };

  // Deselect all cards
  const deselectAllCards = () => {
    setSelectedCards([]);
  };

  const handleDeleteSelected = () => {
    // Create a copy of the selectedCards array since we'll be modifying processedResults
    const cardsToDelete = [...selectedCards];
    
    // Set up batch delete confirmation
    if (cardsToDelete.length > 0) {
      // First collect all valid items
      const itemsToDelete = cardsToDelete
        .map(id => {
          const result = processedResults.find(r => r.id === id);
          if (result) {
            const originalId = result.originalId || originalIdMap[result.id] || null;
            return { 
              id: result.id, 
              type: result.type, 
              originalId 
            };
          }
          return null;
        })
        .filter((item): item is {id: number; type: string; originalId: string | null} => 
          item !== null
        );
      
      // Now set state with the correctly typed array
      setMultiDeleteItems(itemsToDelete);
      
      // Show a custom delete confirmation dialog
      setMultiDeleteDialogOpen(true);
    }

    // Don't reset selection state yet - will be done after confirming deletion
  };

  // Function to handle actual multi-deletion
  const handleConfirmMultiDelete = async () => {
    console.log(`[DELETE UI DEBUG] Confirming multi-delete for ${multiDeleteItems.length} items: ${JSON.stringify(multiDeleteItems)}`);
    
    const deletePromises = multiDeleteItems.map(async (item) => {
      if (!item.originalId) {
        console.error(`[DELETE UI DEBUG] Cannot delete item ID ${item.id}: missing original ID`);
        return null;
      }
      
      try {
        let success = false;
        
        if (item.type === 'transcribe') {
          // Mark the transcription as deleted instead of actually deleting it
          console.log(`[DELETE UI DEBUG] Calling deleteTranscription for item ${item.id} with originalId: ${item.originalId}`);
          success = await deleteTranscription(item.originalId);
          console.log(`[DELETE UI DEBUG] deleteTranscription result for item ${item.id}: ${success}`);
        } else if (item.type === 'summarize' || item.type === 'analyze') {
          // For analyses and summaries, actually delete the record
          console.log(`[DELETE UI DEBUG] Calling deleteAnalysis for item ${item.id} with originalId: ${item.originalId}`);
          success = await deleteAnalysis(item.originalId);
          console.log(`[DELETE UI DEBUG] deleteAnalysis result for item ${item.id}: ${success}`);
        }
        
        return success ? item.id : null;
      } catch (error) {
        console.error(`[DELETE UI DEBUG] Error deleting item ID ${item.id}:`, error);
        return null;
      }
    });
    
    const results = await Promise.all(deletePromises);
    const successfulIds = results.filter(Boolean);
    
    console.log(`[DELETE UI DEBUG] Multi-delete completed: ${successfulIds.length} successful, ${multiDeleteItems.length - successfulIds.length} failed`);
    console.log(`[DELETE UI DEBUG] Successful IDs: ${JSON.stringify(successfulIds)}`);
    
    if (successfulIds.length > 0) {
      console.log(`[DELETE UI DEBUG] Removing ${successfulIds.length} items from UI`);
      // Remove the items from processedResults
      setProcessedResults(prevResults => 
        prevResults.filter(result => !successfulIds.includes(result.id))
      );
      
      // Notify parent component
      if (onResultsChange) {
        console.log('[DELETE UI DEBUG] Notifying parent component of multi-deletion');
        onResultsChange(processedResults.filter(result => !successfulIds.includes(result.id)));
      }
      
      toast.success(`Deleted ${successfulIds.length} items successfully`);
    }
    
    if (successfulIds.length < multiDeleteItems.length) {
      const failedCount = multiDeleteItems.length - successfulIds.length;
      console.error(`[DELETE UI DEBUG] Failed to delete ${failedCount} items`);
      toast.error(`Failed to delete ${failedCount} items`);
    }
    
    setMultiDeleteDialogOpen(false);
    setSelectedCards([]);
    setEditMode(false);
  };

  // Function to handle translation
  const handleTranslate = async (content: string, language: string, title?: string) => {
    console.log("handleTranslate called with:", { content: content?.substring(0, 50) + "...", language, title });
    
    if (!content || !language || language === "english") {
      console.log("Translation aborted: missing content or language, or language is English");
      return;
    }
    
    setIsTranslating(true);
    console.log("isTranslating set to true");
    
    try {
      // Check if we already have a translation for this content and language
      if (selectedCard && selectedCard.originalId) {
        console.log("Checking for existing translation for:", { originalId: selectedCard.originalId, language });
        const existingTranslation = await getTranslation(selectedCard.originalId, language);
        
        if (existingTranslation) {
          console.log(`AudioRecorder - Found existing translation for ${selectedCard.originalId} in ${language}`);
          const translatedContent = existingTranslation.content;
          const translatedTitle = existingTranslation.title || "";
          
          setTranslatedContent(translatedContent);
          setTranslatedTitle(translatedTitle);
          setTranslationId(existingTranslation.id);
          setSelectedLanguage(language);
          
          // If this is a transcript, update the transcript content
          if (selectedCard.type === 'transcribe') {
            // Update the transcript content
            setTranscriptContent(translatedContent);
            
            // Update the transcript map
            setTranscriptMap(prev => ({
              ...prev,
              [selectedCard.id]: translatedContent
            }));
            
            // Update the processed results
            setProcessedResults(prev => prev.map(item => 
              item.id === selectedCard.id 
                ? { 
                    ...item, 
                    content: translatedContent,
                    title: translatedTitle || item.title
                  } 
                : item
            ));
            
            // Notify parent of changes if callback exists
            if (onResultsChange) {
              onResultsChange(
                processedResults.map(item => 
                  item.id === selectedCard.id 
                    ? { 
                        ...item, 
                        content: translatedContent,
                        title: translatedTitle || item.title
                      } 
                    : item
                )
              );
            }
          }
          
          return;
        } else {
          console.log("No existing translation found, proceeding with new translation");
        }
      } else {
        console.log("No originalId available for selectedCard:", selectedCard);
      }
      
      // Translate the content
      console.log("Calling translateText API with:", { contentLength: content.length, language });
      const translationResult = await translateText(content, language);
      console.log("Translation result:", { success: translationResult.success, contentLength: translationResult.content?.length });
      
      if (translationResult.success && translationResult.content) {
        const translatedContent = translationResult.content;
        setTranslatedContent(translatedContent);
        
        // Translate the title if provided
        let translatedTitleText = "";
        if (title) {
          const titleTranslationResult = await translateText(title, language);
          
          if (titleTranslationResult.success && titleTranslationResult.content) {
            translatedTitleText = titleTranslationResult.content;
            setTranslatedTitle(translatedTitleText);
          }
        }
        
        // Store the translation in the database if authenticated
        if (isAuthenticated && selectedCard && selectedCard.originalId) {
          const originalType = selectedCard.type === 'transcribe' 
            ? 'transcription' 
            : selectedCard.type === 'summarize' 
              ? 'summary' 
              : 'analysis';
          
          const translationData = await createTranslation(
            selectedCard.originalId,
            originalType,
            language,
            translatedContent,
            translatedTitleText || title,
            { source: "recorder" }
          );
          
          if (translationData) {
            console.log("Translation saved to database");
            setTranslationId(translationData.id);
          }
        }
        
        // If this is a transcript, update the transcript content
        if (selectedCard && selectedCard.type === 'transcribe') {
          // Update the transcript content
          setTranscriptContent(translatedContent);
          
          // Update the transcript map
          setTranscriptMap(prev => ({
            ...prev,
            [selectedCard.id]: translatedContent
          }));
          
          // Update the processed results
          setProcessedResults(prev => prev.map(item => 
            item.id === selectedCard.id 
              ? { 
                  ...item, 
                  content: translatedContent,
                  title: translatedTitleText || item.title
                } 
              : item
          ));
          
          // Notify parent of changes if callback exists
          if (onResultsChange) {
            onResultsChange(
              processedResults.map(item => 
                item.id === selectedCard.id 
                  ? { 
                      ...item, 
                      content: translatedContent,
                      title: translatedTitleText || item.title
                    } 
                  : item
              )
            );
          }
          
          // Show success message
          toast.success("Transcript translated", {
            description: "The transcript has been translated and will be used for future operations."
          });
        }
      } else {
        toast.error("Translation failed", { 
          description: translationResult.error || "An unknown error occurred" 
        });
        setTranslatedContent("");
        setTranslatedTitle("");
      }
    } catch (error) {
      console.error("Translation error details:", error);
      toast.error("Translation failed", { 
        description: error instanceof Error ? error.message : "An unknown error occurred" 
      });
      setTranslatedContent("");
      setTranslatedTitle("");
    } finally {
      console.log("Translation process completed, setting isTranslating to false");
      setIsTranslating(false);
    }
  };

  // Load translation when card or language changes
  useEffect(() => {
    const loadTranslation = async () => {
      if (selectedCard && selectedCard.originalId && selectedLanguage !== "english") {
        setIsTranslating(true);
        try {
          const existingTranslation = await getTranslation(selectedCard.originalId, selectedLanguage);
          
          if (existingTranslation) {
            console.log(`AudioRecorder - Found existing translation for ${selectedCard.originalId} in ${selectedLanguage}`);
            const translatedContent = existingTranslation.content;
            const translatedTitle = existingTranslation.title || "";
            
            setTranslatedContent(translatedContent);
            setTranslatedTitle(translatedTitle);
            setTranslationId(existingTranslation.id);
            
            // If this is a transcript, update the transcript content
            if (selectedCard.type === 'transcribe') {
              // Update the transcript content
              setTranscriptContent(translatedContent);
              
              // Update the transcript map
              setTranscriptMap(prev => ({
                ...prev,
                [selectedCard.id]: translatedContent
              }));
              
              // Update the processed results
              setProcessedResults(prev => prev.map(item => 
                item.id === selectedCard.id 
                  ? { 
                      ...item, 
                      content: translatedContent,
                      title: translatedTitle || item.title
                    } 
                  : item
              ));
              
              // Notify parent of changes if callback exists
              if (onResultsChange) {
                onResultsChange(
                  processedResults.map(item => 
                    item.id === selectedCard.id 
                      ? { 
                          ...item, 
                          content: translatedContent,
                          title: translatedTitle || item.title
                        } 
                      : item
                  )
                );
              }
            }
          } else {
            // No translation found, reset state
            setTranslatedContent("");
            setTranslatedTitle("");
            setTranslationId(null);
          }
        } catch (error) {
          console.error("Error loading translation:", error);
          setTranslatedContent("");
          setTranslatedTitle("");
          setTranslationId(null);
        } finally {
          setIsTranslating(false);
        }
      } else {
        // Reset translation state when switching back to English
        setTranslatedContent("");
        setTranslatedTitle("");
        setTranslationId(null);
      }
    };
    
    loadTranslation();
  }, [selectedCard, selectedLanguage, getTranslation, onResultsChange, processedResults]);

  // Function to copy content to clipboard
  const copyToClipboard = () => {
    const contentToCopy = translatedContent && selectedLanguage !== "english" 
      ? translatedContent 
      : selectedCard?.content.includes("This is a")
        ? selectedCard.content.replace(/^This is a (summary|analysis) of the audio recording\.\s+/, "")
        : selectedCard?.content;
    
    if (contentToCopy) {
      navigator.clipboard.writeText(contentToCopy)
        .then(() => {
          setCopySuccess(true);
          setTimeout(() => setCopySuccess(false), 2000);
        })
        .catch(err => {
          console.error('Failed to copy text: ', err);
        });
    }
  };

  // Add state variables for custom prompts
  const [customPrompts, setCustomPrompts] = useState<Array<{ id: string; title: string }>>([])
  const [selectedPromptId, setSelectedPromptId] = useState<string>('')
  const [isLoadingPrompts, setIsLoadingPrompts] = useState(false)

  // Add a useEffect hook to load custom prompts
  useEffect(() => {
    const loadCustomPrompts = async () => {
      if (isAuthenticated && selectedAiAction === 'custom-prompt') {
        setIsLoadingPrompts(true)
        try {
          console.log("Loading custom prompts...");
          const supabase = createClient()
          const { data: { user } } = await supabase.auth.getUser()
          
          if (user) {
            const userId = user.id;
            console.log("User authenticated, getting prompts for user ID:", userId);
            const prompts = await getCustomPrompts(userId)
            console.log("Prompts returned from DB:", prompts);
            
            if (prompts && prompts.length > 0) {
              const formattedPrompts = prompts.map(p => ({ id: p.id, title: p.title }));
              console.log("Formatted prompts:", formattedPrompts);
              setCustomPrompts(formattedPrompts);
              
              // Only set the selected prompt ID if it's not already set, or if the current ID isn't in the list
              const promptExists = prompts.some(p => p.id === selectedPromptId);
              if (!selectedPromptId || !promptExists) {
                console.log("Setting selected prompt ID to:", prompts[0].id);
                setSelectedPromptId(prompts[0].id);
              } else {
                console.log("Keeping existing selected prompt ID:", selectedPromptId);
              }
            } else {
              console.warn("No prompts found for user", userId);
              setCustomPrompts([]);
              setSelectedPromptId('');
            }
          } else {
            console.warn("No authenticated user found");
            setCustomPrompts([]);
            setSelectedPromptId('');
          }
        } catch (error) {
          console.error('Error loading custom prompts:', error)
          setCustomPrompts([]);
          setSelectedPromptId('');
        } finally {
          setIsLoadingPrompts(false)
        }
      }
    }
    
    loadCustomPrompts()
  }, [isAuthenticated, selectedAiAction])

  // Edit mode state
  const [editMode, setEditMode] = useState(false);
  const [selectedCards, setSelectedCards] = useState<number[]>([]);
  const [multiDeleteItems, setMultiDeleteItems] = useState<Array<{id: number; type: string; originalId: string | null}>>([]);
  const [multiDeleteDialogOpen, setMultiDeleteDialogOpen] = useState(false);

  return (
    <>
      {processedResults.length > 0 && (
        <div className="mx-auto px-4 z-[60] overflow-y-auto custom-scrollbar" style={{ maxHeight: 'calc(100vh - 100px)' }}>
          <div className="flex justify-center mb-4 space-x-2">
            <Button
              variant="ghost"
              size="sm"
              className="h-8 px-3 bg-white/10 backdrop-blur-md rounded-lg border border-white/20 text-white/70 hover:text-white/90 hover:bg-white/15 flex items-center space-x-1"
              onClick={toggleSortDirection}
            >
              <span>Sort by Date</span>
              {sortDirection === "asc" ? (
                <ArrowUp className="h-4 w-4 ml-1" />
              ) : (
                <ArrowDown className="h-4 w-4 ml-1" />
              )}
            </Button>
            <div className="bg-white/10 backdrop-blur-md rounded-lg border border-white/20 flex overflow-hidden">
              <Button
                variant="ghost"
                size="icon"
                className={`h-8 w-8 rounded-none text-white/70 hover:text-white ${viewMode === 'card' ? 'bg-white/20' : ''} hover:bg-white/15`}
                onClick={() => setViewMode("card")}
                title="Card View"
              >
                <Grid className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                className={`h-8 w-8 rounded-none text-white/70 hover:text-white ${viewMode === 'list' ? 'bg-white/20' : ''} hover:bg-white/15`}
                onClick={() => setViewMode("list")}
                title="List View"
              >
                <List className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                className={`h-8 w-8 rounded-none text-white/70 hover:text-white ${editMode ? 'bg-white/20' : ''} hover:bg-white/15`}
                onClick={() => {
                  setEditMode(!editMode);
                  if (!editMode) {
                    setSelectedCards([]);
                  }
                }}
                title={editMode ? "Cancel Edit" : "Edit"}
              >
                {editMode ? <X className="h-4 w-4" /> : <Pencil className="h-4 w-4" />}
              </Button>
            </div>
          </div>
          
          {viewMode === "card" ? (
            <div className="flex justify-center pb-20 mt-2">
              <div className="max-w-6xl w-full">
                {selectedCards.length > 0 && (
                  <div className="mb-4 flex justify-end gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      className="bg-white/10 hover:bg-white/20 text-white/80 hover:text-white border border-white/20"
                      onClick={deselectAllCards}
                    >
                      <X className="h-4 w-4 mr-2" />
                      Deselect All
                    </Button>
                    <Button
                      variant="destructive"
                      size="sm"
                      className="bg-red-500/20 hover:bg-red-500/30 text-red-400 hover:text-red-300 border border-red-500/30"
                      onClick={handleDeleteSelected}
                    >
                      <Trash2 className="h-4 w-4 mr-2" />
                      Delete Selected ({selectedCards.length})
                    </Button>
                  </div>
                )}
                {editMode && selectedCards.length === 0 && (
                  <div className="mb-4 flex justify-end">
                    <Button
                      variant="outline"
                      size="sm"
                      className="bg-white/10 hover:bg-white/20 text-white/80 hover:text-white border border-white/20"
                      onClick={selectAllCards}
                    >
                      <Check className="h-4 w-4 mr-2" />
                      Select All
                    </Button>
                  </div>
                )}
                <div className="grid grid-cols-1 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-8">
                  {getSortedResults().map(result => (
                    <div key={result.id} className="w-full">
                      <div 
                        className="w-full h-[280px] bg-white/10 backdrop-blur-md rounded-lg border border-white/20 shadow-lg overflow-hidden flex flex-col relative"
                      >
                        {editMode && (
                          <div 
                            className="absolute bottom-2 right-2 z-10"
                            onClick={(e) => toggleCardSelection(result.id, e)}
                          >
                            <div className={`h-5 w-5 rounded-full border-2 ${selectedCards.includes(result.id) ? 'bg-green-500 border-green-600' : 'bg-white/10 border-white/30'} flex items-center justify-center cursor-pointer`}>
                              {selectedCards.includes(result.id) && <Check className="h-3 w-3 text-white" />}
                            </div>
                          </div>
                        )}
                        <div className="p-4 border-b border-white/20 bg-white/5 flex items-center">
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6 rounded-full bg-white/10 hover:bg-red-500/20 text-white/70 hover:text-red-400 flex-shrink-0 mr-2"
                            onClick={(e) => {
                              e.stopPropagation();
                              // Get the original ID from the result or from the originalIdMap
                              const originalId = result.originalId || originalIdMap[result.id] || null;
                              handleDeleteClick(result.id, result.type, originalId);
                            }}
                            disabled={result.generating}
                          >
                            <Trash2 className="h-3 w-3" />
                          </Button>
                          <h4 className="font-medium text-white text-base truncate flex-1">
                            {result.generating ? 
                              (result.type === "summarize" ? "Generating Summary..." : 
                               result.type === "analyze" ? "Generating Analysis..." : 
                               "Processing Transcript...") : 
                              (result.title || (
                                result.type === "summarize" ? "Summary" : 
                                result.type === "analyze" ? "Analysis" : 
                                "Processed Transcript"
                              ))}
                          </h4>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6 rounded-full bg-white/10 hover:bg-white/20 text-white/70 hover:text-white flex-shrink-0 ml-2"
                            onClick={() => toggleCardExpanded(result.id)}
                            disabled={result.generating}
                          >
                            <Maximize2 className="h-3 w-3" />
                          </Button>
                        </div>
                        <div className="p-4 flex-1 overflow-y-auto custom-scrollbar text-sm text-white/90">
                          {result.generating ? (
                            <div className="flex items-center justify-center h-full">
                              <div className="animate-pulse">Generating...</div>
                            </div>
                          ) : (
                            <>
                              <div className="whitespace-pre-line line-clamp-7">
                                {result.content.includes("This is a") ? 
                                  result.content.replace(/^This is a (summary|analysis) of the audio recording\.\s+/, "") : 
                                  result.content}
                              </div>
                              <div className="text-xs text-white/50 absolute bottom-3 left-3 pt-5">
                                <span>{new Date(result.date || Date.now()).toLocaleDateString('en-US', { 
                                  month: 'short', 
                                  day: 'numeric',
                                  hour: '2-digit',
                                  minute: '2-digit'
                                })}</span>
                              </div>
                            </>
                          )}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ) : (
            <div className="w-full mx-auto pb-40 custom-scrollbar">
              <div className="bg-white/10 backdrop-blur-md rounded-lg border border-white/20 shadow-lg overflow-hidden">
                <table className="w-full text-white/90">
                  <thead>
                    <tr className="border-b border-white/20 bg-white/5">
                      <th className="py-3 px-6 text-left font-medium">Title</th>
                      <th className="py-3 px-6 text-left font-medium hidden md:table-cell">Type</th>
                      <th className="py-3 px-6 text-left font-medium hidden md:table-cell">
                        <div className="flex items-center">
                          <span>Date</span>
                          <button 
                            className="ml-1 text-white/50 hover:text-white/90 inline-flex hover:bg-white/15 rounded-full p-0.5"
                            onClick={toggleSortDirection}
                          >
                            {sortDirection === "asc" ? (
                              <ArrowUp className="h-3 w-3" />
                            ) : (
                              <ArrowDown className="h-3 w-3" />
                            )}
                          </button>
                        </div>
                      </th>
                      <th className="py-3 px-6 text-right font-medium">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {getSortedResults().map(result => (
                      <tr key={result.id} className="border-b border-white/10 hover:bg-white/5">
                        <td className="py-3 px-6">
                          {result.generating ? 
                            (result.type === "summarize" ? "Generating Summary..." : 
                             result.type === "analyze" ? "Generating Analysis..." : 
                             "Processing Transcript...") : 
                            (result.title || (
                              result.type === "summarize" ? "Summary" : 
                              result.type === "analyze" ? "Analysis" : 
                              "Processed Transcript"
                            ))}
                        </td>
                        <td className="py-3 px-6 hidden md:table-cell">
                          {result.type === "summarize" ? "Summary" : 
                           result.type === "analyze" ? "Analysis" : 
                           "Transcript"}
                        </td>
                        <td className="py-3 px-6 hidden md:table-cell">
                          {new Date(result.date || Date.now()).toLocaleDateString('en-US', { 
                            year: 'numeric',
                            month: 'short', 
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                          })}
                        </td>
                        <td className="py-3 px-6 text-right">
                          <div className="flex items-center justify-end space-x-2">
                            <Button
                              variant="ghost"
                              size="icon"
                              className="h-6 w-6 rounded-full bg-white/10 hover:bg-white/20 text-white/70 hover:text-white"
                              onClick={() => toggleCardExpanded(result.id)}
                              disabled={result.generating}
                            >
                              <Maximize2 className="h-3 w-3" />
                            </Button>
                            <Button
                              variant="ghost"
                              size="icon"
                              className="h-6 w-6 rounded-full bg-white/10 hover:bg-red-500/20 text-white/70 hover:text-red-400"
                              onClick={() => {
                                const originalId = result.originalId || originalIdMap[result.id] || null;
                                handleDeleteClick(result.id, result.type, originalId);
                              }}
                              disabled={result.generating}
                            >
                              <Trash2 className="h-3 w-3" />
                            </Button>
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Empty state card when there are no recordings */}
      {processedResults.length === 0 && (
        <div className="flex justify-center items-center h-[calc(100vh-200px)]">
          <div className="w-full max-w-md mx-auto">
            <div className="h-[280px] border border-white/20 rounded-lg backdrop-blur-md shadow-lg bg-white/5 flex flex-col items-center justify-center p-6 text-center overflow-hidden">
              <Mic className="h-16 w-16 mb-4 text-white/30" />
              <h3 className="text-xl font-medium text-white mb-2">Ready to Record?</h3>
              <p className="text-white/70 mb-6">Press record at the bottom of the screen and make magic happen</p>
              <div className="w-40 h-10 border border-white/30 rounded-full flex items-center justify-center">
                <div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center animate-pulse">
                  <Mic className="h-4 w-4 text-white/70" />
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Delete confirmation dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent className="bg-white/10 backdrop-blur-md border border-white/20 text-white">
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm deletion</AlertDialogTitle>
            <AlertDialogDescription className="text-white/70">
              Are you sure you want to delete this item? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white/10 hover:bg-white/20 text-white border-white/10">Cancel</AlertDialogCancel>
            <AlertDialogAction 
              className="bg-red-500/20 hover:bg-red-500/30 text-red-400 hover:text-red-300 border border-red-500/30"
              onClick={handleConfirmDelete}
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Transcript removal confirmation dialog */}
      <AlertDialog open={transcriptRemovalDialogOpen} onOpenChange={setTranscriptRemovalDialogOpen}>
        <AlertDialogContent className="bg-white/10 backdrop-blur-md border border-white/20 text-white">
          <AlertDialogHeader>
            <AlertDialogTitle>Remove transcript reference?</AlertDialogTitle>
            <AlertDialogDescription className="text-white/70">
              This will remove the transcript reference from this item.
              The transcript will be marked as deleted but can be recovered by an administrator if needed.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white/10 hover:bg-white/20 text-white border-white/10">Cancel</AlertDialogCancel>
            <AlertDialogAction 
              className="bg-red-500/20 hover:bg-red-500/30 text-red-400 hover:text-red-300 border border-red-500/30"
              onClick={() => handleRemoveTranscriptionReference(transcriptToRemove.analysisId, transcriptToRemove.resultId)}
            >
              Remove
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Multi-delete confirmation dialog */}
      <AlertDialog open={multiDeleteDialogOpen} onOpenChange={setMultiDeleteDialogOpen}>
        <AlertDialogContent className="bg-white/10 backdrop-blur-md border border-white/20 text-white">
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm multiple deletion</AlertDialogTitle>
            <AlertDialogDescription className="text-white/70">
              Are you sure you want to delete {multiDeleteItems.length} selected items? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white/10 hover:bg-white/20 text-white border-white/10">
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction 
              className="bg-red-500/20 hover:bg-red-500/30 text-red-400 hover:text-red-300 border border-red-500/30"
              onClick={handleConfirmMultiDelete}
            >
              Delete All
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <Card className={`fixed bottom-4 left-1/2 transform -translate-x-1/2 ${isMinimized ? 'w-auto' : 'w-full max-w-md'} overflow-hidden bg-white/10 backdrop-blur-md border-0 shadow-xl z-[100] transition-all duration-300`}>
        <div className="absolute top-2 right-2 z-10">
          <Button
            variant="ghost"
            size="icon"
            className="h-6 w-6 rounded-full bg-white/10 hover:bg-white/20 text-white/70 hover:text-white"
            onClick={() => setIsMinimized(!isMinimized)}
          >
            {isMinimized ? <Maximize2 className="h-3 w-3" /> : <X className="h-3 w-3" />}
          </Button>
        </div>
        {isMinimized ? (
          <div className="p-3 flex items-center space-x-3">
            <Button
              variant="default"
              style={getRecordingButtonStyles()}
              className="rounded-full p-0 flex items-center justify-center h-10 w-10"
              onClick={() => {
                if (isRecording) {
                  stopRecording();
                } else {
                  setIsMinimized(false);
                  startRecording();
                }
              }}
            >
              {isRecording ? <Square className="h-4 w-4" /> : <Mic className="h-4 w-4" />}
            </Button>
            <span className="text-xs text-white/80 font-medium">
              {isRecording ? formatTimeRemaining() : "Record Audio"}
            </span>
          </div>
        ) : (
        <CardContent className="p-5">
          <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as "record" | "upload" | "write")} className="w-full">
            <TabsList className="grid w-full grid-cols-3 mb-6 bg-white/10 p-1 rounded-lg">
              <TabsTrigger
                value="record"
                className="data-[state=active]:bg-white/20 data-[state=active]:text-white data-[state=active]:shadow-md text-white/70"
              >
                Record
              </TabsTrigger>
              <TabsTrigger
                value="upload"
                className="data-[state=active]:bg-white/20 data-[state=active]:text-white data-[state=active]:shadow-md text-white/70"
              >
                Upload
              </TabsTrigger>
              <TabsTrigger
                value="write"
                className="data-[state=active]:bg-white/20 data-[state=active]:text-white data-[state=active]:shadow-md text-white/70"
              >
                Write
              </TabsTrigger>
            </TabsList>

            <TabsContent value="record" className="space-y-5">
              {/* Recording controls */}
              <div className="space-y-4">
                {/* Timer display with controls on mobile */}
                {isRecording ? (
                  <div className="text-center md:block flex items-center justify-between">
                    <div className="text-3xl font-mono font-bold text-white">
                      {formatTimeRemaining()}
                    </div>
                    <div className="text-xs text-white/70 mt-1 hidden md:block">
                      {isAuthenticated 
                        ? "Premium: 10 minute recording limit" 
                        : "Free: 5 minute recording limit"}
                    </div>
                    {/* Mobile-only control while recording */}
                    <div className="flex items-center space-x-2 md:hidden">
                      <Button
                        variant="destructive"
                        style={getStopButtonStyles()}
                        className="rounded-full p-0 flex items-center justify-center h-10 w-10"
                        onClick={stopRecording}
                      >
                        <Square className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ) : isPostRecording && (
                  <div className="text-center md:block flex items-center justify-between">
                    <span className="text-3xl font-mono font-bold text-white">
                      {formatTime(recordingTime)}
                    </span>
                    {/* Controls on mobile */}
                    <div className="flex items-center space-x-2 md:hidden">
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-10 h-10 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={resetRecorder}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-10 h-10 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={togglePlayRecorded}
                      >
                        {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
                      </Button>
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-10 h-10 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={resetRecorder}
                      >
                        <PlusCircle className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                )}

                {/* Control buttons - hidden on mobile when post-recording */}
                <div className="flex justify-center gap-4">
                  {isRecording ? (
                    <Button
                      variant="destructive"
                      style={getStopButtonStyles()}
                      className="rounded-full p-0 flex items-center justify-center md:flex hidden"
                      onClick={stopRecording}
                    >
                      <Square className="h-6 w-6" />
                    </Button>
                  ) : isPostRecording ? (
                    <div className="flex gap-3 md:flex hidden">
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-12 h-12 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={resetRecorder}
                      >
                        <Trash2 className="h-5 w-5" />
                      </Button>
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-12 h-12 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={togglePlayRecorded}
                      >
                        {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5" />}
                      </Button>
                      <Button
                        variant="outline"
                        size="icon"
                        className="rounded-full w-12 h-12 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                        onClick={resetRecorder}
                      >
                        <PlusCircle className="h-5 w-5" />
                      </Button>
                    </div>
                  ) : (
                    <div className="flex flex-col items-center">
                      <Button
                        variant="default"
                        style={getRecordingButtonStyles()}
                        className="rounded-full p-0 flex items-center justify-center mb-2"
                        onClick={startRecording}
                      >
                        <Mic className="h-6 w-6" />
                      </Button>
                      <span className="text-xs text-white/60">Tap to record</span>
                    </div>
                  )}
                </div>
              </div>

              {/* AI Processing section - only show after recording */}
              {isPostRecording && audioURL && (
                <div className="space-y-4 mt-6 pt-6 border-t border-white/20">
                  <Select
                    value={selectedAiAction}
                    onValueChange={setSelectedAiAction}
                  >
                    <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                      <SelectValue placeholder="Select AI action" />
                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                        <path d="m6 9 6 6 6-6"/>
                      </svg>
                    </SelectTrigger>
                    <SelectContent className="bg-slate-800 border-white/20 text-white">
                      <SelectItem value="transcribe" className="text-base focus:bg-white/10 focus:text-white">Process Transcript</SelectItem>
                      {isAuthenticated && (
                        <SelectItem value="custom-prompt" className="text-base focus:bg-white/10 focus:text-white">Use Custom Prompt</SelectItem>
                      )}
                    </SelectContent>
                  </Select>

                  {/* Add transcript processing type selector when 'transcribe' is selected */}
                  {selectedAiAction === "transcribe" && (
                    <Select
                      value={transcriptProcessingType}
                      onValueChange={(value) => setTranscriptProcessingType(value as 'keep-as-is' | 'condense' | 'expand')}
                    >
                      <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                        <SelectValue placeholder="Select processing type" />
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                          <path d="m6 9 6 6 6-6"/>
                        </svg>
                      </SelectTrigger>
                      <SelectContent className="bg-slate-800 border-white/20 text-white">
                        <SelectItem value="keep-as-is" className="text-base focus:bg-white/10 focus:text-white">Keep As Is (Minor Fixes)</SelectItem>
                        <SelectItem value="condense" className="text-base focus:bg-white/10 focus:text-white">Condense (Remove Fluff)</SelectItem>
                        <SelectItem value="expand" className="text-base focus:bg-white/10 focus:text-white">Expand (Add Context)</SelectItem>
                      </SelectContent>
                    </Select>
                  )}

                  {selectedAiAction === "custom-prompt" && (
                    <Select
                      value={selectedPromptId}
                      onValueChange={setSelectedPromptId}
                    >
                      <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                        <SelectValue placeholder={isLoadingPrompts ? "Loading prompts..." : "Select a prompt"} />
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                          <path d="m6 9 6 6 6-6"/>
                        </svg>
                      </SelectTrigger>
                      <SelectContent className="bg-slate-800 border-white/20 text-white">
                        {customPrompts.length > 0 ? (
                          customPrompts.map(prompt => (
                            <SelectItem key={prompt.id} value={prompt.id} className="text-base focus:bg-white/10 focus:text-white">
                              {prompt.title}
                            </SelectItem>
                          ))
                        ) : (
                          <div className="px-2 py-4 text-center text-white/60 text-sm">
                            No custom prompts found. Create them in your account settings.
                          </div>
                        )}
                      </SelectContent>
                    </Select>
                  )}

                  <Button
                    variant="default"
                    className="w-full bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white h-12 text-base"
                    disabled={aiProcessing}
                    onClick={processWithAI}
                  >
                    {aiProcessing ? "Processing..." : selectedAiAction === "transcribe" 
                      ? `Process ${transcriptProcessingType === 'keep-as-is' ? 'Transcript' : transcriptProcessingType === 'condense' ? 'Condensed Transcript' : 'Expanded Transcript'}`
                      : selectedAiAction === "custom-prompt"
                        ? "Process with Custom Prompt"
                        : `${selectedAiAction.charAt(0).toUpperCase() + selectedAiAction.slice(1)} Audio`}
                  </Button>
                  
                  {/* Display transcript in the recorder card */}
                  <div className="mt-4 p-4 pb-0 bg-white/10 rounded-lg border border-white/20 text-sm text-white/90">
                    <div className="flex justify-between items-center mb-2">
                      <div 
                        className="font-medium text-white flex items-center cursor-pointer"
                        onClick={() => setIsTranscriptCollapsed(!isTranscriptCollapsed)}
                      >
                        <h4>Transcript</h4>
                        <ChevronDown className={`ml-1 h-4 w-4 transition-transform duration-200 md:hidden ${isTranscriptCollapsed ? '' : 'transform rotate-180'}`} />
                      </div>
                      {!aiProcessing && getTranscriptContent(lastTranscriptionNumericId || 0) && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 text-xs bg-white/10 hover:bg-white/20 text-white/70 hover:text-white"
                          onClick={() => {
                            const transcriptContent = getTranscriptContent(lastTranscriptionNumericId || 0);
                            if (transcriptContent) {
                              navigator.clipboard.writeText(transcriptContent)
                                .then(() => {
                                  toast.success("Transcript copied to clipboard");
                                })
                                .catch(err => {
                                  console.error('Failed to copy text: ', err);
                                  toast.error("Failed to copy transcript");
                                });
                            }
                          }}
                        >
                          <Copy className="h-3.5 w-3.5 mr-1" /> Copy
                        </Button>
                      )}
                    </div>
                    <div className={`whitespace-pre-line transition-all duration-300 ${
                      isTranscriptCollapsed 
                      ? 'max-h-0 overflow-hidden md:max-h-[300px] md:overflow-y-auto' 
                      : 'max-h-[300px] overflow-y-auto'
                    }`}>
                      {aiProcessing ? (
                        <div className="flex items-center justify-center py-4">
                          <div className="animate-pulse">Generating transcript...</div>
                        </div>
                      ) : (
                        getTranscriptContent(lastTranscriptionNumericId || 0)
                      )}
                    </div>
                    
                    <div className="px-4 py-3 mt-4 border-t border-white/10 bg-white/5 text-xs text-white/60 flex justify-between items-center -mx-4 rounded-b-lg">
                      <span>{new Date().toLocaleDateString('en-US', { 
                        year: 'numeric',
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      })}</span>
                      
                      <div className="flex items-center space-x-3">
                        <span>{selectedCard?.date}</span>
                        
                        {/* Removing the translate dropdown and button */}
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </TabsContent>

            <TabsContent value="upload" className="space-y-5">
              {!uploadedFile ? (
                <div className="flex flex-col items-center justify-center p-6 border-2 border-dashed border-white/20 rounded-lg bg-white/5">
                  <Upload className="h-8 w-8 text-white/50 mb-2" />
                  <p className="text-sm text-white/70 mb-4 text-center">
                    Upload an audio or video file to process with AI
                  </p>
                  <input
                    type="file"
                    id="audio-upload"
                    accept="audio/*,video/mp4"
                    className="hidden"
                    onChange={handleFileUpload}
                  />
                  <label
                    htmlFor="audio-upload"
                    className="inline-flex items-center justify-center px-4 py-2 bg-white/20 text-white text-sm font-medium rounded-md hover:bg-white/30 cursor-pointer transition-colors"
                  >
                    Select File
                  </label>
                </div>
              ) : (
                <div className="p-4 bg-white/10 rounded-lg border border-white/20">
                  <div className="flex items-center justify-between mb-4">
                    <div>
                      <h3 className="font-medium text-white">{uploadedFile.name}</h3>
                      <p className="text-xs text-white/60">
                        {(uploadedFile.size / 1024 / 1024).toFixed(2)} MB
                      </p>
                    </div>
                    <Button
                      variant="outline"
                      size="icon"
                      className="h-8 w-8 border-white/20 bg-white/10 text-white hover:bg-white/20 hover:text-white"
                      onClick={togglePlayUploaded}
                    >
                      {isUploadedPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
                    </Button>
                  </div>
                  
                  {/* Display transcript for uploaded file */}
                  <div className="mt-4 p-4 bg-white/10 rounded-lg border border-white/20 text-sm text-white/90">
                    <div 
                      className="font-medium mb-2 text-white flex items-center cursor-pointer"
                      onClick={() => setIsTranscriptCollapsed(!isTranscriptCollapsed)}
                    >
                      <h4 className="font-medium">Transcript</h4>
                      <ChevronDown className={`ml-1 h-4 w-4 transition-transform duration-200 md:hidden ${isTranscriptCollapsed ? '' : 'transform rotate-180'}`} />
                    </div>
                    <div className={`whitespace-pre-line transition-all duration-300 ${
                      isTranscriptCollapsed 
                      ? 'max-h-0 overflow-hidden md:max-h-[300px] md:overflow-y-auto' 
                      : 'max-h-[300px] overflow-y-auto'
                    }`}>
                      {aiProcessing ? (
                        <div className="flex items-center justify-center py-4">
                          <div className="animate-pulse">Generating transcript...</div>
                        </div>
                      ) : (
                        getTranscriptContent(lastTranscriptionNumericId || 0)
                      )}
                    </div>
                  </div>
                  
                  {/* AI Processing options for uploaded file */}
                  <div className="space-y-4 mt-6 pt-6 border-t border-white/20">
                    <Select
                      value={selectedAiAction}
                      onValueChange={setSelectedAiAction}
                    >
                      <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                        <SelectValue placeholder="Select AI action" />
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                          <path d="m6 9 6 6 6-6"/>
                        </svg>
                      </SelectTrigger>
                      <SelectContent className="bg-slate-800 border-white/20 text-white">
                        <SelectItem value="transcribe" className="text-base focus:bg-white/10 focus:text-white">Process Transcript</SelectItem>
                        {isAuthenticated && (
                          <SelectItem value="custom-prompt" className="text-base focus:bg-white/10 focus:text-white">Use Custom Prompt</SelectItem>
                        )}
                      </SelectContent>
                    </Select>

                    {/* Add transcript processing type selector when 'transcribe' is selected */}
                    {selectedAiAction === "transcribe" && (
                      <Select
                        value={transcriptProcessingType}
                        onValueChange={(value) => setTranscriptProcessingType(value as 'keep-as-is' | 'condense' | 'expand')}
                      >
                        <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                          <SelectValue placeholder="Select processing type" />
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                            <path d="m6 9 6 6 6-6"/>
                          </svg>
                        </SelectTrigger>
                        <SelectContent className="bg-slate-800 border-white/20 text-white">
                          <SelectItem value="keep-as-is" className="text-base focus:bg-white/10 focus:text-white">Keep As Is (Minor Fixes)</SelectItem>
                          <SelectItem value="condense" className="text-base focus:bg-white/10 focus:text-white">Condense (Remove Fluff)</SelectItem>
                          <SelectItem value="expand" className="text-base focus:bg-white/10 focus:text-white">Expand (Add Context)</SelectItem>
                        </SelectContent>
                      </Select>
                    )}

                    {selectedAiAction === "custom-prompt" && (
                      <Select
                        value={selectedPromptId}
                        onValueChange={setSelectedPromptId}
                      >
                        <SelectTrigger className="w-full h-12 text-white text-base bg-white/10 border-white/20 focus:ring-white/30 [&_svg]:text-white [&_svg]:opacity-100">
                          <SelectValue placeholder={isLoadingPrompts ? "Loading prompts..." : "Select a prompt"} />
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2">
                            <path d="m6 9 6 6 6-6"/>
                          </svg>
                        </SelectTrigger>
                        <SelectContent className="bg-slate-800 border-white/20 text-white">
                          {customPrompts.length > 0 ? (
                            customPrompts.map(prompt => (
                              <SelectItem key={prompt.id} value={prompt.id} className="text-base focus:bg-white/10 focus:text-white">
                                {prompt.title}
                              </SelectItem>
                            ))
                          ) : (
                            <div className="px-2 py-4 text-center text-white/60 text-sm">
                              No custom prompts found. Create them in your account settings.
                            </div>
                          )}
                        </SelectContent>
                      </Select>
                    )}

                    <Button
                      variant="default"
                      className="w-full bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white h-12 text-base"
                      disabled={aiProcessing}
                      onClick={processWithAI}
                    >
                      {aiProcessing ? "Processing..." : selectedAiAction === "transcribe" 
                        ? `Process ${transcriptProcessingType === 'keep-as-is' ? 'Transcript' : transcriptProcessingType === 'condense' ? 'Condensed Transcript' : 'Expanded Transcript'}`
                        : selectedAiAction === "custom-prompt"
                          ? "Process with Custom Prompt"
                          : `${selectedAiAction.charAt(0).toUpperCase() + selectedAiAction.slice(1)} Audio`}
                    </Button>
                  </div>
                </div>
              )}
            </TabsContent>
            
            <TabsContent value="write" className="space-y-5">
              <div className="p-4 bg-white/10 rounded-lg border border-white/20">
                <div className="flex items-center justify-between mb-4">
                  <div>
                    <h3 className="font-medium text-white">Write or paste your text</h3>
                    <p className="text-xs text-white/60">
                      Type or paste text to analyze with AI
                    </p>
                  </div>
                  <FileText className="h-5 w-5 text-white/60" />
                </div>
                
                <Textarea 
                  value={textContent}
                  onChange={(e) => setTextContent(e.target.value)}
                  name="custom-text"
                  placeholder="Enter your text here..."
                  className="min-h-[200px] bg-white/5 border-white/20 text-white resize-y mb-4"
                />
                
                <div className="space-y-4">
                  <div className="grid grid-cols-1 gap-3">
                    <div className="w-full">
                      <Select
                        value={selectedAiAction}
                        onValueChange={setSelectedAiAction}
                      >
                        <SelectTrigger className="w-full h-10 bg-white/10 border-white/20 text-white [&_svg]:text-white [&_svg]:opacity-100">
                          <SelectValue placeholder="Select action" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="transcribe">Process Text</SelectItem>
                          <SelectItem value="custom-prompt">Use Custom Prompt</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  
                  {selectedAiAction === "transcribe" && (
                    <div className="w-full">
                      <Select
                        value={transcriptProcessingType}
                        onValueChange={(value) => setTranscriptProcessingType(value as 'keep-as-is' | 'condense' | 'expand')}
                      >
                        <SelectTrigger className="w-full h-10 bg-white/10 border-white/20 text-white [&_svg]:text-white [&_svg]:opacity-100">
                          <SelectValue placeholder="Select processing type" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="keep-as-is">Keep Text As-Is</SelectItem>
                          <SelectItem value="condense">Condense Text</SelectItem>
                          <SelectItem value="expand">Expand Text</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  )}
                  
                  {selectedAiAction === "custom-prompt" && (
                    <div className="w-full">
                      <Select
                        value={selectedPromptId}
                        onValueChange={setSelectedPromptId}
                      >
                        <SelectTrigger className="w-full h-10 bg-white/10 border-white/20 text-white [&_svg]:text-white [&_svg]:opacity-100">
                          <SelectValue placeholder="Select prompt" />
                        </SelectTrigger>
                        <SelectContent>
                          {customPrompts.length > 0 ? (
                            customPrompts.map(prompt => (
                              <SelectItem key={prompt.id} value={prompt.id}>
                                {prompt.title}
                              </SelectItem>
                            ))
                          ) : (
                            <SelectItem value="no-prompts-found" disabled>
                              No custom prompts found
                            </SelectItem>
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                  )}
                  
                  <Button
                    variant="default"
                    className="w-full bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white h-12 text-base"
                    disabled={aiProcessing || !textContent.trim() || (selectedAiAction === "custom-prompt" && (!selectedPromptId || customPrompts.length === 0))}
                    onClick={processWithAI}
                  >
                    {aiProcessing ? "Processing..." : selectedAiAction === "transcribe" 
                      ? `Process ${transcriptProcessingType === 'keep-as-is' ? 'Text' : transcriptProcessingType === 'condense' ? 'Condensed Text' : 'Expanded Text'}`
                      : selectedAiAction === "custom-prompt"
                        ? "Process with Custom Prompt"
                        : `${selectedAiAction.charAt(0).toUpperCase() + selectedAiAction.slice(1)} Text`}
                  </Button>
                </div>
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
        )}
        {/* Only show footer with save button after recording and when not minimized */}
        {isPostRecording && audioURL && !isMinimized && (
          <CardFooter className="px-5 py-3 border-t border-white/20 bg-white/5 text-xs text-white/60">
            <div className="w-full flex justify-between items-center">
              <span>Audio Recorder</span>
              <a
                href="#"
                className="text-white/80 hover:text-white hover:underline transition-colors"
                onClick={(e) => {
                  e.preventDefault()
                  if (audioURL) {
                    const a = document.createElement("a")
                    a.href = audioURL
                    const extension = getFileExtensionFromMimeType(currentMimeType);
                    a.download = `recording.${extension}`
                    a.click()
                  }
                }}
              >
                <Save className="h-4 w-4 inline-block mr-1" />
                Save Recording
              </a>
            </div>
          </CardFooter>
        )}
        {/* Audio element for playback */}
        <audio 
          ref={audioRef} 
          className="hidden" 
          controls={false}
          preload="auto"
          onError={(e) => console.error("Audio error:", e)}
        />
      </Card>

      {/* Modal for expanded card */}
      <Dialog open={modalOpen} onOpenChange={setModalOpen}>
        <DialogContent className="bg-white/10 backdrop-blur-md border border-white/20 text-white max-w-4xl min-h-[450px] max-h-[80vh] flex flex-col p-0 rounded-lg overflow-hidden shadow-lg">
          <DialogHeader className="sr-only">
            <DialogTitle>
              {selectedCard?.title || (
                selectedCard?.type === "summarize" ? "Summary" : 
                selectedCard?.type === "analyze" ? "Analysis" : 
                "Processed Transcript"
              )}
            </DialogTitle>
          </DialogHeader>
          <div className="p-3 border-b border-white/20 bg-white/5 flex items-center">
            <h4 className="font-medium text-white text-base truncate flex-1">
              {translatedTitle && selectedLanguage !== "english" 
                ? translatedTitle 
                : selectedCard?.title || (selectedCard?.type === 'transcribe' 
                  ? 'Transcript' 
                  : selectedCard?.type === 'summarize' 
                    ? 'Summary' 
                    : 'Analysis')}
            </h4>
            <DialogClose className="h-6 w-6 rounded-full bg-white/10 hover:bg-white/20 text-white/70 hover:text-white flex-shrink-0 ml-2 flex items-center justify-center">
              <X className="h-3 w-3" />
            </DialogClose>
          </div>
          <div className="p-3 flex-1 overflow-y-auto custom-scrollbar text-sm text-white/90 flex flex-col">
            {selectedCard ? (
              <>
                <div className="whitespace-pre-line flex-1">
                  {isTranslating ? (
                    <div className="flex items-center justify-center py-8">
                      <div className="animate-pulse">Translating...</div>
                    </div>
                  ) : translatedContent && selectedLanguage !== "english" ? (
                    <div className="whitespace-pre-line">
                      {translatedContent}
                    </div>
                  ) : (
                    <div className="whitespace-pre-line">
                      {selectedCard.content.includes("This is a") ? 
                        selectedCard.content.replace(/^This is a (summary|analysis) of the audio recording\.\s+/, "") : 
                        selectedCard.content}
                    </div>
                  )}
                </div>
                
                <div className="mt-4">
                  {/* Only show the Original Transcript section when we have a valid transcriptionId */}
                  {selectedCard.type !== 'transcribe' && 
                   ((selectedCard.originalId) || 
                    (originalIdMap[selectedCard.id])) && (
                    <>
                      <div 
                        className="flex items-center cursor-pointer p-2 hover:bg-white/5 rounded-md transition-colors"
                        onClick={(e) => {
                          e.stopPropagation();
                          
                          // Toggle the visibility of the transcript element
                          const transcriptEl = document.getElementById(`modal-transcript-${selectedCard.id}`);
                          if (transcriptEl) {
                            transcriptEl.classList.toggle('hidden');
                          }
                          
                          // Check if we have a transcript
                          if (!transcriptMap[selectedCard.id]) {
                            console.log(`AudioRecorder - Need to fetch transcript for card ${selectedCard.id}`);
                            
                            // Set a loading state while fetching
                            setTranscriptMap(prevMap => ({
                              ...prevMap,
                              [selectedCard.id]: "Loading transcript..."
                            }));
                            
                            // For transcripts, we can directly use the content
                            if (selectedCard.type === 'transcribe') {
                              console.log(`AudioRecorder - Using direct content for transcript card ${selectedCard.id}`);
                              setTranscriptMap(prevMap => ({
                                ...prevMap,
                                [selectedCard.id]: selectedCard.content
                              }));
                            }
                            else if ((selectedCard.type === 'summarize' || selectedCard.type === 'analyze') && 
                                    (selectedCard.originalId || originalIdMap[selectedCard.id])) {
                              const originalId = selectedCard.originalId || originalIdMap[selectedCard.id];
                              console.log(`AudioRecorder - Fetching transcript for analysis ID ${originalId}`);
                              // For summaries and analyses, we need to get the transcription via the analysis record
                              fetchTranscriptionForAnalysis(originalId, selectedCard.id)
                                .then(content => {
                                  if (content) {
                                    setTranscriptMap(prevMap => ({
                                      ...prevMap,
                                      [selectedCard.id]: content
                                    }));
                                  }
                                });
                            }
                          }
                        }}
                      >
                        <h5 className="font-medium text-white/90 text-sm flex-1 truncate">Original Transcript</h5>
                        <ChevronDown className="h-4 w-4 text-white/70 flex-shrink-0 ml-2" />
                      </div>
                      <div id={`modal-transcript-${selectedCard.id}`} className="p-3 bg-white/5 rounded-lg hidden">
                        <div className="whitespace-pre-line text-white/80 text-xs max-h-[200px] overflow-y-auto custom-scrollbar">
                          {transcriptMap[selectedCard.id] || "Loading transcript..."}
                        </div>
                      </div>
                    </>
                  )}
                </div>
              </>
            ) : (
              <div className="flex items-center justify-center h-full">
                <div className="animate-pulse">Loading...</div>
              </div>
            )}
          </div>
          
          {selectedCard && (
            <div className="px-4 py-3 border-t border-white/10 bg-white/5 text-xs text-white/60 flex justify-between items-center">
              <span>{new Date(selectedCard.date || Date.now()).toLocaleDateString('en-US', { 
                year: 'numeric',
                month: 'short', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              })}</span>
              
              <div className="flex items-center space-x-3">
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-6 w-6 p-0 text-white/70 hover:text-white hover:bg-white/10"
                  onClick={copyToClipboard}
                  title="Copy to clipboard"
                >
                  {copySuccess ? (
                    <span className="text-green-400 text-xs">Copied!</span>
                  ) : (
                    <Copy className="h-3.5 w-3.5" />
                  )}
                </Button>
                
                {/* Add edit button */}
                {selectedCard.type === 'transcribe' && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-6 w-6 p-0 text-white/70 hover:text-white hover:bg-white/10"
                    onClick={() => {
                      // Close the modal
                      setModalOpen(false);
                      
                      // Set the transcript content for further processing
                      setTextContent(selectedCard.content);
                      setTranscriptContent(selectedCard.content);
                      
                      // Ensure the recorder is expanded, not minimized
                      setIsMinimized(false);
                      
                      // Switch to text input mode by changing the activeTab state
                      setActiveTab("write");
                      
                      // Focus the textarea after a small delay to ensure UI update
                      setTimeout(() => {
                        const textarea = document.querySelector('textarea[name="custom-text"]') as HTMLTextAreaElement;
                        if (textarea) {
                          textarea.focus();
                        }
                      }, 100);
                    }}
                    title="Edit transcript"
                  >
                    <Pencil className="h-3.5 w-3.5" />
                  </Button>
                )}
                
                {/* If the card is not a transcript but has an original transcript, also add edit button */}
                {selectedCard.type !== 'transcribe' && (
                  (selectedCard.originalId || originalIdMap[selectedCard.id]) && 
                  transcriptMap[selectedCard.id] && 
                  transcriptMap[selectedCard.id] !== "__TRANSCRIPT_DELETED__" && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-6 w-6 p-0 text-white/70 hover:text-white hover:bg-white/10"
                      onClick={() => {
                        // Close the modal
                        setModalOpen(false);
                        
                        // Set the original transcript content for further processing
                        const transcriptContent = transcriptMap[selectedCard.id];
                        setTextContent(transcriptContent);
                        setTranscriptContent(transcriptContent);
                        
                        // Ensure the recorder is expanded, not minimized
                        setIsMinimized(false);
                        
                        // Switch to text input mode by changing the activeTab state
                        setActiveTab("write");
                        
                        // Focus the textarea after a small delay to ensure UI update
                        setTimeout(() => {
                          const textarea = document.querySelector('textarea[name="custom-text"]') as HTMLTextAreaElement;
                          if (textarea) {
                            textarea.focus();
                          }
                        }, 100);
                      }}
                      title="Use original transcript for new transform"
                    >
                      <Pencil className="h-3.5 w-3.5" />
                    </Button>
                  )
                )}
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>
    </>
  )
}

